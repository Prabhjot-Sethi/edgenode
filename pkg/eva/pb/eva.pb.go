// Code generated by protoc-gen-go. DO NOT EDIT.
// source: eva.proto

package eva

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	ela "github.com/smartedgemec/appliance-ce/pkg/ela/pb"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type LifecycleCommand_Command int32

const (
	LifecycleCommand_START   LifecycleCommand_Command = 0
	LifecycleCommand_STOP    LifecycleCommand_Command = 1
	LifecycleCommand_RESTART LifecycleCommand_Command = 2
)

var LifecycleCommand_Command_name = map[int32]string{
	0: "START",
	1: "STOP",
	2: "RESTART",
}

var LifecycleCommand_Command_value = map[string]int32{
	"START":   0,
	"STOP":    1,
	"RESTART": 2,
}

func (x LifecycleCommand_Command) String() string {
	return proto.EnumName(LifecycleCommand_Command_name, int32(x))
}

func (LifecycleCommand_Command) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_78739cf76c9af146, []int{2, 0}
}

type ApplicationID struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ApplicationID) Reset()         { *m = ApplicationID{} }
func (m *ApplicationID) String() string { return proto.CompactTextString(m) }
func (*ApplicationID) ProtoMessage()    {}
func (*ApplicationID) Descriptor() ([]byte, []int) {
	return fileDescriptor_78739cf76c9af146, []int{0}
}

func (m *ApplicationID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ApplicationID.Unmarshal(m, b)
}
func (m *ApplicationID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ApplicationID.Marshal(b, m, deterministic)
}
func (m *ApplicationID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationID.Merge(m, src)
}
func (m *ApplicationID) XXX_Size() int {
	return xxx_messageInfo_ApplicationID.Size(m)
}
func (m *ApplicationID) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationID.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationID proto.InternalMessageInfo

func (m *ApplicationID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type VNFID struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VNFID) Reset()         { *m = VNFID{} }
func (m *VNFID) String() string { return proto.CompactTextString(m) }
func (*VNFID) ProtoMessage()    {}
func (*VNFID) Descriptor() ([]byte, []int) {
	return fileDescriptor_78739cf76c9af146, []int{1}
}

func (m *VNFID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VNFID.Unmarshal(m, b)
}
func (m *VNFID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VNFID.Marshal(b, m, deterministic)
}
func (m *VNFID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VNFID.Merge(m, src)
}
func (m *VNFID) XXX_Size() int {
	return xxx_messageInfo_VNFID.Size(m)
}
func (m *VNFID) XXX_DiscardUnknown() {
	xxx_messageInfo_VNFID.DiscardUnknown(m)
}

var xxx_messageInfo_VNFID proto.InternalMessageInfo

func (m *VNFID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type LifecycleCommand struct {
	Id                   string                   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Cmd                  LifecycleCommand_Command `protobuf:"varint,2,opt,name=cmd,proto3,enum=openness.eva.LifecycleCommand_Command" json:"cmd,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *LifecycleCommand) Reset()         { *m = LifecycleCommand{} }
func (m *LifecycleCommand) String() string { return proto.CompactTextString(m) }
func (*LifecycleCommand) ProtoMessage()    {}
func (*LifecycleCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_78739cf76c9af146, []int{2}
}

func (m *LifecycleCommand) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LifecycleCommand.Unmarshal(m, b)
}
func (m *LifecycleCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LifecycleCommand.Marshal(b, m, deterministic)
}
func (m *LifecycleCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LifecycleCommand.Merge(m, src)
}
func (m *LifecycleCommand) XXX_Size() int {
	return xxx_messageInfo_LifecycleCommand.Size(m)
}
func (m *LifecycleCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_LifecycleCommand.DiscardUnknown(m)
}

var xxx_messageInfo_LifecycleCommand proto.InternalMessageInfo

func (m *LifecycleCommand) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *LifecycleCommand) GetCmd() LifecycleCommand_Command {
	if m != nil {
		return m.Cmd
	}
	return LifecycleCommand_START
}

type ContainerIP struct {
	Ip                   string   `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContainerIP) Reset()         { *m = ContainerIP{} }
func (m *ContainerIP) String() string { return proto.CompactTextString(m) }
func (*ContainerIP) ProtoMessage()    {}
func (*ContainerIP) Descriptor() ([]byte, []int) {
	return fileDescriptor_78739cf76c9af146, []int{3}
}

func (m *ContainerIP) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ContainerIP.Unmarshal(m, b)
}
func (m *ContainerIP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ContainerIP.Marshal(b, m, deterministic)
}
func (m *ContainerIP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerIP.Merge(m, src)
}
func (m *ContainerIP) XXX_Size() int {
	return xxx_messageInfo_ContainerIP.Size(m)
}
func (m *ContainerIP) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerIP.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerIP proto.InternalMessageInfo

func (m *ContainerIP) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

// ContainerInfo represents the state of a running application.
type ContainerInfo struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContainerInfo) Reset()         { *m = ContainerInfo{} }
func (m *ContainerInfo) String() string { return proto.CompactTextString(m) }
func (*ContainerInfo) ProtoMessage()    {}
func (*ContainerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_78739cf76c9af146, []int{4}
}

func (m *ContainerInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ContainerInfo.Unmarshal(m, b)
}
func (m *ContainerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ContainerInfo.Marshal(b, m, deterministic)
}
func (m *ContainerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerInfo.Merge(m, src)
}
func (m *ContainerInfo) XXX_Size() int {
	return xxx_messageInfo_ContainerInfo.Size(m)
}
func (m *ContainerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerInfo proto.InternalMessageInfo

func (m *ContainerInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func init() {
	proto.RegisterEnum("openness.eva.LifecycleCommand_Command", LifecycleCommand_Command_name, LifecycleCommand_Command_value)
	proto.RegisterType((*ApplicationID)(nil), "openness.eva.ApplicationID")
	proto.RegisterType((*VNFID)(nil), "openness.eva.VNFID")
	proto.RegisterType((*LifecycleCommand)(nil), "openness.eva.LifecycleCommand")
	proto.RegisterType((*ContainerIP)(nil), "openness.eva.ContainerIP")
	proto.RegisterType((*ContainerInfo)(nil), "openness.eva.ContainerInfo")
}

func init() { proto.RegisterFile("eva.proto", fileDescriptor_78739cf76c9af146) }

var fileDescriptor_78739cf76c9af146 = []byte{
	// 527 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x54, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0x8d, 0x4d, 0xd3, 0x24, 0x53, 0x28, 0x61, 0x8b, 0xa0, 0x24, 0x04, 0x2a, 0x1f, 0x50, 0x25,
	0xa4, 0x8d, 0x14, 0x84, 0x80, 0x13, 0xa4, 0x69, 0x53, 0x45, 0x2a, 0x21, 0xb2, 0x83, 0x0f, 0xdc,
	0x36, 0xf6, 0x24, 0xac, 0x64, 0xef, 0x5a, 0xf6, 0xc6, 0x52, 0x38, 0x73, 0xe1, 0xb7, 0x70, 0xe3,
	0x0f, 0xf1, 0x57, 0x50, 0xec, 0x24, 0xb5, 0x43, 0x13, 0x44, 0x7b, 0xeb, 0x69, 0xa5, 0xf9, 0x78,
	0xfb, 0xf6, 0xcd, 0xdb, 0x81, 0x0a, 0xc6, 0x8c, 0x06, 0xa1, 0x54, 0x92, 0xdc, 0x95, 0x01, 0x0a,
	0x81, 0x51, 0x44, 0x31, 0x66, 0xb5, 0xfa, 0x44, 0xca, 0x89, 0x87, 0xcd, 0x24, 0x37, 0x9a, 0x8e,
	0x9b, 0xe8, 0x07, 0x6a, 0x96, 0x96, 0xd6, 0x2a, 0xe8, 0x2d, 0xba, 0x8c, 0xe7, 0x70, 0xaf, 0x1d,
	0x04, 0x1e, 0x77, 0x98, 0xe2, 0x52, 0xf4, 0x4e, 0xc9, 0x3e, 0xe8, 0xdc, 0x3d, 0xd4, 0x8e, 0xb4,
	0xe3, 0x8a, 0xa9, 0x73, 0xd7, 0x78, 0x0c, 0x45, 0xbb, 0xdf, 0xbd, 0x22, 0xf1, 0x43, 0x83, 0xea,
	0x05, 0x1f, 0xa3, 0x33, 0x73, 0x3c, 0xec, 0x48, 0xdf, 0x67, 0xc2, 0x5d, 0x2f, 0x22, 0x6f, 0xe1,
	0x8e, 0xe3, 0xbb, 0x87, 0xfa, 0x91, 0x76, 0xbc, 0xdf, 0x7a, 0x41, 0xb3, 0x14, 0xe9, 0x7a, 0x33,
	0x5d, 0x9c, 0xe6, 0xbc, 0xc5, 0x78, 0x09, 0xa5, 0x25, 0x68, 0x05, 0x8a, 0xd6, 0xb0, 0x6d, 0x0e,
	0xab, 0x05, 0x52, 0x86, 0x1d, 0x6b, 0xf8, 0x69, 0x50, 0xd5, 0xc8, 0x1e, 0x94, 0xcc, 0xb3, 0x34,
	0xac, 0x1b, 0x0d, 0xd8, 0xeb, 0x48, 0xa1, 0x18, 0x17, 0x18, 0xf6, 0x06, 0x09, 0x8b, 0x60, 0xc5,
	0x22, 0x98, 0x3f, 0xf2, 0x32, 0x2d, 0xc6, 0x72, 0x9d, 0x66, 0xeb, 0xa7, 0x0e, 0x4f, 0x33, 0x32,
	0x9c, 0x62, 0xe0, 0xc9, 0x99, 0x8f, 0x42, 0x59, 0x18, 0xc6, 0xdc, 0x41, 0xd2, 0x85, 0xfb, 0x69,
	0x70, 0x85, 0x43, 0x9e, 0x64, 0x5e, 0xe3, 0x31, 0x9a, 0x69, 0xaf, 0x3d, 0xa2, 0xa9, 0xfa, 0x74,
	0xa9, 0x3e, 0x3d, 0x9b, 0xab, 0x6f, 0x14, 0xc8, 0x7b, 0x28, 0xa7, 0x38, 0xf6, 0xc7, 0x6b, 0x03,
	0x98, 0xe8, 0x26, 0x10, 0xd7, 0x03, 0x68, 0x43, 0xf9, 0xb3, 0x58, 0x00, 0xd4, 0xf3, 0x03, 0xc9,
	0x19, 0x61, 0x33, 0x44, 0xeb, 0x97, 0x0e, 0xf5, 0x4c, 0xed, 0x6a, 0x8e, 0x4b, 0xb1, 0xda, 0x50,
	0xb4, 0x14, 0x0b, 0x15, 0x79, 0xb6, 0x7d, 0xe0, 0x5b, 0x58, 0x7e, 0x80, 0x1d, 0x4b, 0xc9, 0xe0,
	0x06, 0x08, 0x1d, 0x28, 0x99, 0x18, 0xdd, 0x90, 0x46, 0x0f, 0x2a, 0xe7, 0xa8, 0x2c, 0xc5, 0xd4,
	0x34, 0xda, 0xae, 0x56, 0x23, 0x3f, 0x8b, 0x4b, 0x4d, 0x92, 0x5e, 0xa3, 0xd0, 0xfa, 0xae, 0xc3,
	0x43, 0xbb, 0xdf, 0xfd, 0xdb, 0x5a, 0xaf, 0x61, 0x37, 0x0d, 0x92, 0x07, 0x79, 0x0c, 0xbb, 0xdf,
	0xdd, 0x3a, 0xc7, 0x0c, 0xb5, 0x83, 0x3c, 0xb5, 0xe4, 0xc3, 0xfe, 0x93, 0x12, 0x79, 0x93, 0xf1,
	0xd2, 0x7f, 0xdd, 0xfd, 0x2e, 0xe3, 0xa1, 0x2b, 0xaf, 0xde, 0xec, 0x9d, 0xdf, 0x1a, 0x1c, 0xd8,
	0xfd, 0xee, 0xed, 0xf5, 0x4c, 0xcb, 0x87, 0xc6, 0x7c, 0x49, 0x84, 0xd2, 0xf3, 0x30, 0xb4, 0x79,
	0xa8, 0xa6, 0xcc, 0xe3, 0xdf, 0x12, 0x9f, 0xb4, 0x27, 0x28, 0x14, 0xb9, 0x80, 0xea, 0x39, 0xaa,
	0xd5, 0x22, 0x39, 0x99, 0xf5, 0x06, 0xb9, 0xaf, 0x1c, 0x33, 0x9a, 0x59, 0x66, 0xb5, 0xfa, 0xa6,
	0x94, 0x18, 0x4b, 0xa3, 0x70, 0xd2, 0xf8, 0x52, 0x9f, 0x70, 0xf5, 0x75, 0x3a, 0xa2, 0x8e, 0xf4,
	0x9b, 0x91, 0xcf, 0x42, 0x85, 0xee, 0x04, 0x7d, 0x74, 0x9a, 0x18, 0xb3, 0xd1, 0x6e, 0xc2, 0xef,
	0xd5, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa0, 0x88, 0x17, 0xe0, 0x29, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ApplicationDeploymentServiceClient is the client API for ApplicationDeploymentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ApplicationDeploymentServiceClient interface {
	DeployContainer(ctx context.Context, in *ela.Application, opts ...grpc.CallOption) (*empty.Empty, error)
	DeployVM(ctx context.Context, in *ela.Application, opts ...grpc.CallOption) (*empty.Empty, error)
	Redeploy(ctx context.Context, in *ela.Application, opts ...grpc.CallOption) (*empty.Empty, error)
	Undeploy(ctx context.Context, in *ApplicationID, opts ...grpc.CallOption) (*empty.Empty, error)
}

type applicationDeploymentServiceClient struct {
	cc *grpc.ClientConn
}

func NewApplicationDeploymentServiceClient(cc *grpc.ClientConn) ApplicationDeploymentServiceClient {
	return &applicationDeploymentServiceClient{cc}
}

func (c *applicationDeploymentServiceClient) DeployContainer(ctx context.Context, in *ela.Application, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.eva.ApplicationDeploymentService/DeployContainer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationDeploymentServiceClient) DeployVM(ctx context.Context, in *ela.Application, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.eva.ApplicationDeploymentService/DeployVM", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationDeploymentServiceClient) Redeploy(ctx context.Context, in *ela.Application, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.eva.ApplicationDeploymentService/Redeploy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationDeploymentServiceClient) Undeploy(ctx context.Context, in *ApplicationID, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.eva.ApplicationDeploymentService/Undeploy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApplicationDeploymentServiceServer is the server API for ApplicationDeploymentService service.
type ApplicationDeploymentServiceServer interface {
	DeployContainer(context.Context, *ela.Application) (*empty.Empty, error)
	DeployVM(context.Context, *ela.Application) (*empty.Empty, error)
	Redeploy(context.Context, *ela.Application) (*empty.Empty, error)
	Undeploy(context.Context, *ApplicationID) (*empty.Empty, error)
}

func RegisterApplicationDeploymentServiceServer(s *grpc.Server, srv ApplicationDeploymentServiceServer) {
	s.RegisterService(&_ApplicationDeploymentService_serviceDesc, srv)
}

func _ApplicationDeploymentService_DeployContainer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ela.Application)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationDeploymentServiceServer).DeployContainer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.eva.ApplicationDeploymentService/DeployContainer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationDeploymentServiceServer).DeployContainer(ctx, req.(*ela.Application))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationDeploymentService_DeployVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ela.Application)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationDeploymentServiceServer).DeployVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.eva.ApplicationDeploymentService/DeployVM",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationDeploymentServiceServer).DeployVM(ctx, req.(*ela.Application))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationDeploymentService_Redeploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ela.Application)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationDeploymentServiceServer).Redeploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.eva.ApplicationDeploymentService/Redeploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationDeploymentServiceServer).Redeploy(ctx, req.(*ela.Application))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationDeploymentService_Undeploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplicationID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationDeploymentServiceServer).Undeploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.eva.ApplicationDeploymentService/Undeploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationDeploymentServiceServer).Undeploy(ctx, req.(*ApplicationID))
	}
	return interceptor(ctx, in, info, handler)
}

var _ApplicationDeploymentService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.eva.ApplicationDeploymentService",
	HandlerType: (*ApplicationDeploymentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeployContainer",
			Handler:    _ApplicationDeploymentService_DeployContainer_Handler,
		},
		{
			MethodName: "DeployVM",
			Handler:    _ApplicationDeploymentService_DeployVM_Handler,
		},
		{
			MethodName: "Redeploy",
			Handler:    _ApplicationDeploymentService_Redeploy_Handler,
		},
		{
			MethodName: "Undeploy",
			Handler:    _ApplicationDeploymentService_Undeploy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eva.proto",
}

// ApplicationLifecycleServiceClient is the client API for ApplicationLifecycleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ApplicationLifecycleServiceClient interface {
	Start(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error)
	Stop(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error)
	Restart(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error)
	GetStatus(ctx context.Context, in *ApplicationID, opts ...grpc.CallOption) (*ela.LifecycleStatus, error)
}

type applicationLifecycleServiceClient struct {
	cc *grpc.ClientConn
}

func NewApplicationLifecycleServiceClient(cc *grpc.ClientConn) ApplicationLifecycleServiceClient {
	return &applicationLifecycleServiceClient{cc}
}

func (c *applicationLifecycleServiceClient) Start(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.eva.ApplicationLifecycleService/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationLifecycleServiceClient) Stop(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.eva.ApplicationLifecycleService/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationLifecycleServiceClient) Restart(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.eva.ApplicationLifecycleService/Restart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationLifecycleServiceClient) GetStatus(ctx context.Context, in *ApplicationID, opts ...grpc.CallOption) (*ela.LifecycleStatus, error) {
	out := new(ela.LifecycleStatus)
	err := c.cc.Invoke(ctx, "/openness.eva.ApplicationLifecycleService/GetStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApplicationLifecycleServiceServer is the server API for ApplicationLifecycleService service.
type ApplicationLifecycleServiceServer interface {
	Start(context.Context, *LifecycleCommand) (*empty.Empty, error)
	Stop(context.Context, *LifecycleCommand) (*empty.Empty, error)
	Restart(context.Context, *LifecycleCommand) (*empty.Empty, error)
	GetStatus(context.Context, *ApplicationID) (*ela.LifecycleStatus, error)
}

func RegisterApplicationLifecycleServiceServer(s *grpc.Server, srv ApplicationLifecycleServiceServer) {
	s.RegisterService(&_ApplicationLifecycleService_serviceDesc, srv)
}

func _ApplicationLifecycleService_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationLifecycleServiceServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.eva.ApplicationLifecycleService/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationLifecycleServiceServer).Start(ctx, req.(*LifecycleCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationLifecycleService_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationLifecycleServiceServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.eva.ApplicationLifecycleService/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationLifecycleServiceServer).Stop(ctx, req.(*LifecycleCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationLifecycleService_Restart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationLifecycleServiceServer).Restart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.eva.ApplicationLifecycleService/Restart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationLifecycleServiceServer).Restart(ctx, req.(*LifecycleCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationLifecycleService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplicationID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationLifecycleServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.eva.ApplicationLifecycleService/GetStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationLifecycleServiceServer).GetStatus(ctx, req.(*ApplicationID))
	}
	return interceptor(ctx, in, info, handler)
}

var _ApplicationLifecycleService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.eva.ApplicationLifecycleService",
	HandlerType: (*ApplicationLifecycleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Start",
			Handler:    _ApplicationLifecycleService_Start_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _ApplicationLifecycleService_Stop_Handler,
		},
		{
			MethodName: "Restart",
			Handler:    _ApplicationLifecycleService_Restart_Handler,
		},
		{
			MethodName: "GetStatus",
			Handler:    _ApplicationLifecycleService_GetStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eva.proto",
}

// VNFDeploymentServiceClient is the client API for VNFDeploymentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VNFDeploymentServiceClient interface {
	Deploy(ctx context.Context, in *ela.VNF, opts ...grpc.CallOption) (*empty.Empty, error)
	GetStatus(ctx context.Context, in *VNFID, opts ...grpc.CallOption) (*ela.LifecycleStatus, error)
	Redeploy(ctx context.Context, in *ela.VNF, opts ...grpc.CallOption) (*empty.Empty, error)
	Undeploy(ctx context.Context, in *VNFID, opts ...grpc.CallOption) (*empty.Empty, error)
}

type vNFDeploymentServiceClient struct {
	cc *grpc.ClientConn
}

func NewVNFDeploymentServiceClient(cc *grpc.ClientConn) VNFDeploymentServiceClient {
	return &vNFDeploymentServiceClient{cc}
}

func (c *vNFDeploymentServiceClient) Deploy(ctx context.Context, in *ela.VNF, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.eva.VNFDeploymentService/Deploy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNFDeploymentServiceClient) GetStatus(ctx context.Context, in *VNFID, opts ...grpc.CallOption) (*ela.LifecycleStatus, error) {
	out := new(ela.LifecycleStatus)
	err := c.cc.Invoke(ctx, "/openness.eva.VNFDeploymentService/GetStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNFDeploymentServiceClient) Redeploy(ctx context.Context, in *ela.VNF, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.eva.VNFDeploymentService/Redeploy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNFDeploymentServiceClient) Undeploy(ctx context.Context, in *VNFID, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.eva.VNFDeploymentService/Undeploy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VNFDeploymentServiceServer is the server API for VNFDeploymentService service.
type VNFDeploymentServiceServer interface {
	Deploy(context.Context, *ela.VNF) (*empty.Empty, error)
	GetStatus(context.Context, *VNFID) (*ela.LifecycleStatus, error)
	Redeploy(context.Context, *ela.VNF) (*empty.Empty, error)
	Undeploy(context.Context, *VNFID) (*empty.Empty, error)
}

func RegisterVNFDeploymentServiceServer(s *grpc.Server, srv VNFDeploymentServiceServer) {
	s.RegisterService(&_VNFDeploymentService_serviceDesc, srv)
}

func _VNFDeploymentService_Deploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ela.VNF)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFDeploymentServiceServer).Deploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.eva.VNFDeploymentService/Deploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFDeploymentServiceServer).Deploy(ctx, req.(*ela.VNF))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNFDeploymentService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNFID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFDeploymentServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.eva.VNFDeploymentService/GetStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFDeploymentServiceServer).GetStatus(ctx, req.(*VNFID))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNFDeploymentService_Redeploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ela.VNF)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFDeploymentServiceServer).Redeploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.eva.VNFDeploymentService/Redeploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFDeploymentServiceServer).Redeploy(ctx, req.(*ela.VNF))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNFDeploymentService_Undeploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNFID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFDeploymentServiceServer).Undeploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.eva.VNFDeploymentService/Undeploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFDeploymentServiceServer).Undeploy(ctx, req.(*VNFID))
	}
	return interceptor(ctx, in, info, handler)
}

var _VNFDeploymentService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.eva.VNFDeploymentService",
	HandlerType: (*VNFDeploymentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Deploy",
			Handler:    _VNFDeploymentService_Deploy_Handler,
		},
		{
			MethodName: "GetStatus",
			Handler:    _VNFDeploymentService_GetStatus_Handler,
		},
		{
			MethodName: "Redeploy",
			Handler:    _VNFDeploymentService_Redeploy_Handler,
		},
		{
			MethodName: "Undeploy",
			Handler:    _VNFDeploymentService_Undeploy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eva.proto",
}

// VNFLifecycleServiceClient is the client API for VNFLifecycleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VNFLifecycleServiceClient interface {
	Start(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error)
	Stop(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error)
	Restart(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error)
}

type vNFLifecycleServiceClient struct {
	cc *grpc.ClientConn
}

func NewVNFLifecycleServiceClient(cc *grpc.ClientConn) VNFLifecycleServiceClient {
	return &vNFLifecycleServiceClient{cc}
}

func (c *vNFLifecycleServiceClient) Start(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.eva.VNFLifecycleService/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNFLifecycleServiceClient) Stop(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.eva.VNFLifecycleService/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNFLifecycleServiceClient) Restart(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.eva.VNFLifecycleService/Restart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VNFLifecycleServiceServer is the server API for VNFLifecycleService service.
type VNFLifecycleServiceServer interface {
	Start(context.Context, *LifecycleCommand) (*empty.Empty, error)
	Stop(context.Context, *LifecycleCommand) (*empty.Empty, error)
	Restart(context.Context, *LifecycleCommand) (*empty.Empty, error)
}

func RegisterVNFLifecycleServiceServer(s *grpc.Server, srv VNFLifecycleServiceServer) {
	s.RegisterService(&_VNFLifecycleService_serviceDesc, srv)
}

func _VNFLifecycleService_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFLifecycleServiceServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.eva.VNFLifecycleService/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFLifecycleServiceServer).Start(ctx, req.(*LifecycleCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNFLifecycleService_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFLifecycleServiceServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.eva.VNFLifecycleService/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFLifecycleServiceServer).Stop(ctx, req.(*LifecycleCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNFLifecycleService_Restart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFLifecycleServiceServer).Restart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.eva.VNFLifecycleService/Restart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFLifecycleServiceServer).Restart(ctx, req.(*LifecycleCommand))
	}
	return interceptor(ctx, in, info, handler)
}

var _VNFLifecycleService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.eva.VNFLifecycleService",
	HandlerType: (*VNFLifecycleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Start",
			Handler:    _VNFLifecycleService_Start_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _VNFLifecycleService_Stop_Handler,
		},
		{
			MethodName: "Restart",
			Handler:    _VNFLifecycleService_Restart_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eva.proto",
}

// ControllerVirtualizationAgentClient is the client API for ControllerVirtualizationAgent service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ControllerVirtualizationAgentClient interface {
	// GetContainerByIP queries an external orchestrator (e.g. Kubernetes) for
	// an application running (not stopped) on the Node making the request with
	// a given (active) Pod IP address. The identity of the Node making the
	// request is determined by the TLS certificate it presents at transport
	// authentication time.
	GetContainerByIP(ctx context.Context, in *ContainerIP, opts ...grpc.CallOption) (*ContainerInfo, error)
}

type controllerVirtualizationAgentClient struct {
	cc *grpc.ClientConn
}

func NewControllerVirtualizationAgentClient(cc *grpc.ClientConn) ControllerVirtualizationAgentClient {
	return &controllerVirtualizationAgentClient{cc}
}

func (c *controllerVirtualizationAgentClient) GetContainerByIP(ctx context.Context, in *ContainerIP, opts ...grpc.CallOption) (*ContainerInfo, error) {
	out := new(ContainerInfo)
	err := c.cc.Invoke(ctx, "/openness.eva.ControllerVirtualizationAgent/GetContainerByIP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ControllerVirtualizationAgentServer is the server API for ControllerVirtualizationAgent service.
type ControllerVirtualizationAgentServer interface {
	// GetContainerByIP queries an external orchestrator (e.g. Kubernetes) for
	// an application running (not stopped) on the Node making the request with
	// a given (active) Pod IP address. The identity of the Node making the
	// request is determined by the TLS certificate it presents at transport
	// authentication time.
	GetContainerByIP(context.Context, *ContainerIP) (*ContainerInfo, error)
}

func RegisterControllerVirtualizationAgentServer(s *grpc.Server, srv ControllerVirtualizationAgentServer) {
	s.RegisterService(&_ControllerVirtualizationAgent_serviceDesc, srv)
}

func _ControllerVirtualizationAgent_GetContainerByIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerIP)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerVirtualizationAgentServer).GetContainerByIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.eva.ControllerVirtualizationAgent/GetContainerByIP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerVirtualizationAgentServer).GetContainerByIP(ctx, req.(*ContainerIP))
	}
	return interceptor(ctx, in, info, handler)
}

var _ControllerVirtualizationAgent_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.eva.ControllerVirtualizationAgent",
	HandlerType: (*ControllerVirtualizationAgentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetContainerByIP",
			Handler:    _ControllerVirtualizationAgent_GetContainerByIP_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eva.proto",
}
