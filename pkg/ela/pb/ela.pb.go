// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ela.proto

package pb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type LifecycleCommand_Command int32

const (
	LifecycleCommand_START   LifecycleCommand_Command = 0
	LifecycleCommand_STOP    LifecycleCommand_Command = 1
	LifecycleCommand_RESTART LifecycleCommand_Command = 2
)

var LifecycleCommand_Command_name = map[int32]string{
	0: "START",
	1: "STOP",
	2: "RESTART",
}

var LifecycleCommand_Command_value = map[string]int32{
	"START":   0,
	"STOP":    1,
	"RESTART": 2,
}

func (x LifecycleCommand_Command) String() string {
	return proto.EnumName(LifecycleCommand_Command_name, int32(x))
}

func (LifecycleCommand_Command) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{0, 0}
}

type LifecycleStatus_Status int32

const (
	LifecycleStatus_UNKNOWN   LifecycleStatus_Status = 0
	LifecycleStatus_DEPLOYING LifecycleStatus_Status = 1
	LifecycleStatus_READY     LifecycleStatus_Status = 2
	LifecycleStatus_STARTING  LifecycleStatus_Status = 3
	LifecycleStatus_RUNNING   LifecycleStatus_Status = 4
	LifecycleStatus_STOPPING  LifecycleStatus_Status = 5
	LifecycleStatus_STOPPED   LifecycleStatus_Status = 6
	LifecycleStatus_ERROR     LifecycleStatus_Status = 7
)

var LifecycleStatus_Status_name = map[int32]string{
	0: "UNKNOWN",
	1: "DEPLOYING",
	2: "READY",
	3: "STARTING",
	4: "RUNNING",
	5: "STOPPING",
	6: "STOPPED",
	7: "ERROR",
}

var LifecycleStatus_Status_value = map[string]int32{
	"UNKNOWN":   0,
	"DEPLOYING": 1,
	"READY":     2,
	"STARTING":  3,
	"RUNNING":   4,
	"STOPPING":  5,
	"STOPPED":   6,
	"ERROR":     7,
}

func (x LifecycleStatus_Status) String() string {
	return proto.EnumName(LifecycleStatus_Status_name, int32(x))
}

func (LifecycleStatus_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{1, 0}
}

type TrafficTarget_TargetAction int32

const (
	TrafficTarget_ACCEPT TrafficTarget_TargetAction = 0
	TrafficTarget_REJECT TrafficTarget_TargetAction = 1
	TrafficTarget_DROP   TrafficTarget_TargetAction = 2
)

var TrafficTarget_TargetAction_name = map[int32]string{
	0: "ACCEPT",
	1: "REJECT",
	2: "DROP",
}

var TrafficTarget_TargetAction_value = map[string]int32{
	"ACCEPT": 0,
	"REJECT": 1,
	"DROP":   2,
}

func (x TrafficTarget_TargetAction) String() string {
	return proto.EnumName(TrafficTarget_TargetAction_name, int32(x))
}

func (TrafficTarget_TargetAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{12, 0}
}

type NetworkInterface_InterfaceDriver int32

const (
	NetworkInterface_KERNEL    NetworkInterface_InterfaceDriver = 0
	NetworkInterface_USERSPACE NetworkInterface_InterfaceDriver = 1
)

var NetworkInterface_InterfaceDriver_name = map[int32]string{
	0: "KERNEL",
	1: "USERSPACE",
}

var NetworkInterface_InterfaceDriver_value = map[string]int32{
	"KERNEL":    0,
	"USERSPACE": 1,
}

func (x NetworkInterface_InterfaceDriver) String() string {
	return proto.EnumName(NetworkInterface_InterfaceDriver_name, int32(x))
}

func (NetworkInterface_InterfaceDriver) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{15, 0}
}

type NetworkInterface_InterfaceType int32

const (
	NetworkInterface_NONE          NetworkInterface_InterfaceType = 0
	NetworkInterface_UPSTREAM      NetworkInterface_InterfaceType = 1
	NetworkInterface_DOWNSTREAM    NetworkInterface_InterfaceType = 2
	NetworkInterface_BIDIRECTIONAL NetworkInterface_InterfaceType = 3
	NetworkInterface_BREAKOUT      NetworkInterface_InterfaceType = 4
)

var NetworkInterface_InterfaceType_name = map[int32]string{
	0: "NONE",
	1: "UPSTREAM",
	2: "DOWNSTREAM",
	3: "BIDIRECTIONAL",
	4: "BREAKOUT",
}

var NetworkInterface_InterfaceType_value = map[string]int32{
	"NONE":          0,
	"UPSTREAM":      1,
	"DOWNSTREAM":    2,
	"BIDIRECTIONAL": 3,
	"BREAKOUT":      4,
}

func (x NetworkInterface_InterfaceType) String() string {
	return proto.EnumName(NetworkInterface_InterfaceType_name, int32(x))
}

func (NetworkInterface_InterfaceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{15, 1}
}

type NetworkSetting_Status int32

const (
	NetworkSetting_NONE   NetworkSetting_Status = 0
	NetworkSetting_STATIC NetworkSetting_Status = 1
	NetworkSetting_DHCPv4 NetworkSetting_Status = 2
	NetworkSetting_DHCPv6 NetworkSetting_Status = 3
	NetworkSetting_SLAAC  NetworkSetting_Status = 4
)

var NetworkSetting_Status_name = map[int32]string{
	0: "NONE",
	1: "STATIC",
	2: "DHCPv4",
	3: "DHCPv6",
	4: "SLAAC",
}

var NetworkSetting_Status_value = map[string]int32{
	"NONE":   0,
	"STATIC": 1,
	"DHCPv4": 2,
	"DHCPv6": 3,
	"SLAAC":  4,
}

func (x NetworkSetting_Status) String() string {
	return proto.EnumName(NetworkSetting_Status_name, int32(x))
}

func (NetworkSetting_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{19, 0}
}

type LifecycleCommand struct {
	Id                   string                   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Cmd                  LifecycleCommand_Command `protobuf:"varint,2,opt,name=cmd,proto3,enum=openness.ela.LifecycleCommand_Command" json:"cmd,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *LifecycleCommand) Reset()         { *m = LifecycleCommand{} }
func (m *LifecycleCommand) String() string { return proto.CompactTextString(m) }
func (*LifecycleCommand) ProtoMessage()    {}
func (*LifecycleCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{0}
}

func (m *LifecycleCommand) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LifecycleCommand.Unmarshal(m, b)
}
func (m *LifecycleCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LifecycleCommand.Marshal(b, m, deterministic)
}
func (m *LifecycleCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LifecycleCommand.Merge(m, src)
}
func (m *LifecycleCommand) XXX_Size() int {
	return xxx_messageInfo_LifecycleCommand.Size(m)
}
func (m *LifecycleCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_LifecycleCommand.DiscardUnknown(m)
}

var xxx_messageInfo_LifecycleCommand proto.InternalMessageInfo

func (m *LifecycleCommand) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *LifecycleCommand) GetCmd() LifecycleCommand_Command {
	if m != nil {
		return m.Cmd
	}
	return LifecycleCommand_START
}

type LifecycleStatus struct {
	Status               LifecycleStatus_Status `protobuf:"varint,1,opt,name=status,proto3,enum=openness.ela.LifecycleStatus_Status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *LifecycleStatus) Reset()         { *m = LifecycleStatus{} }
func (m *LifecycleStatus) String() string { return proto.CompactTextString(m) }
func (*LifecycleStatus) ProtoMessage()    {}
func (*LifecycleStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{1}
}

func (m *LifecycleStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LifecycleStatus.Unmarshal(m, b)
}
func (m *LifecycleStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LifecycleStatus.Marshal(b, m, deterministic)
}
func (m *LifecycleStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LifecycleStatus.Merge(m, src)
}
func (m *LifecycleStatus) XXX_Size() int {
	return xxx_messageInfo_LifecycleStatus.Size(m)
}
func (m *LifecycleStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_LifecycleStatus.DiscardUnknown(m)
}

var xxx_messageInfo_LifecycleStatus proto.InternalMessageInfo

func (m *LifecycleStatus) GetStatus() LifecycleStatus_Status {
	if m != nil {
		return m.Status
	}
	return LifecycleStatus_UNKNOWN
}

// Application message - contains information about the application
// we're about to deploy (or one already deployed).
// image string is used to build the url to download the image from over http
// url is the following: http://${controller_name}/app_images/${image}
// - so the last part is our image string - which is basically a file name
// with a possible additional path prefixed
type Application struct {
	Id                   string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Vendor               string                 `protobuf:"bytes,3,opt,name=vendor,proto3" json:"vendor,omitempty"`
	Description          string                 `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Image                string                 `protobuf:"bytes,5,opt,name=image,proto3" json:"image,omitempty"`
	Cores                int32                  `protobuf:"varint,6,opt,name=cores,proto3" json:"cores,omitempty"`
	Memory               int32                  `protobuf:"varint,7,opt,name=memory,proto3" json:"memory,omitempty"`
	Status               LifecycleStatus_Status `protobuf:"varint,8,opt,name=status,proto3,enum=openness.ela.LifecycleStatus_Status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *Application) Reset()         { *m = Application{} }
func (m *Application) String() string { return proto.CompactTextString(m) }
func (*Application) ProtoMessage()    {}
func (*Application) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{2}
}

func (m *Application) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Application.Unmarshal(m, b)
}
func (m *Application) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Application.Marshal(b, m, deterministic)
}
func (m *Application) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Application.Merge(m, src)
}
func (m *Application) XXX_Size() int {
	return xxx_messageInfo_Application.Size(m)
}
func (m *Application) XXX_DiscardUnknown() {
	xxx_messageInfo_Application.DiscardUnknown(m)
}

var xxx_messageInfo_Application proto.InternalMessageInfo

func (m *Application) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Application) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Application) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *Application) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Application) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Application) GetCores() int32 {
	if m != nil {
		return m.Cores
	}
	return 0
}

func (m *Application) GetMemory() int32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *Application) GetStatus() LifecycleStatus_Status {
	if m != nil {
		return m.Status
	}
	return LifecycleStatus_UNKNOWN
}

type Applications struct {
	Applications         []*Application `protobuf:"bytes,1,rep,name=applications,proto3" json:"applications,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Applications) Reset()         { *m = Applications{} }
func (m *Applications) String() string { return proto.CompactTextString(m) }
func (*Applications) ProtoMessage()    {}
func (*Applications) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{3}
}

func (m *Applications) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Applications.Unmarshal(m, b)
}
func (m *Applications) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Applications.Marshal(b, m, deterministic)
}
func (m *Applications) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Applications.Merge(m, src)
}
func (m *Applications) XXX_Size() int {
	return xxx_messageInfo_Applications.Size(m)
}
func (m *Applications) XXX_DiscardUnknown() {
	xxx_messageInfo_Applications.DiscardUnknown(m)
}

var xxx_messageInfo_Applications proto.InternalMessageInfo

func (m *Applications) GetApplications() []*Application {
	if m != nil {
		return m.Applications
	}
	return nil
}

type VNF struct {
	Id                   string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Vendor               string                 `protobuf:"bytes,3,opt,name=vendor,proto3" json:"vendor,omitempty"`
	Description          string                 `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Image                string                 `protobuf:"bytes,5,opt,name=image,proto3" json:"image,omitempty"`
	Cores                int32                  `protobuf:"varint,6,opt,name=cores,proto3" json:"cores,omitempty"`
	Memory               int32                  `protobuf:"varint,7,opt,name=memory,proto3" json:"memory,omitempty"`
	Status               LifecycleStatus_Status `protobuf:"varint,8,opt,name=status,proto3,enum=openness.ela.LifecycleStatus_Status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *VNF) Reset()         { *m = VNF{} }
func (m *VNF) String() string { return proto.CompactTextString(m) }
func (*VNF) ProtoMessage()    {}
func (*VNF) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{4}
}

func (m *VNF) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VNF.Unmarshal(m, b)
}
func (m *VNF) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VNF.Marshal(b, m, deterministic)
}
func (m *VNF) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VNF.Merge(m, src)
}
func (m *VNF) XXX_Size() int {
	return xxx_messageInfo_VNF.Size(m)
}
func (m *VNF) XXX_DiscardUnknown() {
	xxx_messageInfo_VNF.DiscardUnknown(m)
}

var xxx_messageInfo_VNF proto.InternalMessageInfo

func (m *VNF) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *VNF) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VNF) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *VNF) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *VNF) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *VNF) GetCores() int32 {
	if m != nil {
		return m.Cores
	}
	return 0
}

func (m *VNF) GetMemory() int32 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *VNF) GetStatus() LifecycleStatus_Status {
	if m != nil {
		return m.Status
	}
	return LifecycleStatus_UNKNOWN
}

type VNFs struct {
	Vnfs                 []*VNF   `protobuf:"bytes,1,rep,name=vnfs,proto3" json:"vnfs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VNFs) Reset()         { *m = VNFs{} }
func (m *VNFs) String() string { return proto.CompactTextString(m) }
func (*VNFs) ProtoMessage()    {}
func (*VNFs) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{5}
}

func (m *VNFs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VNFs.Unmarshal(m, b)
}
func (m *VNFs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VNFs.Marshal(b, m, deterministic)
}
func (m *VNFs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VNFs.Merge(m, src)
}
func (m *VNFs) XXX_Size() int {
	return xxx_messageInfo_VNFs.Size(m)
}
func (m *VNFs) XXX_DiscardUnknown() {
	xxx_messageInfo_VNFs.DiscardUnknown(m)
}

var xxx_messageInfo_VNFs proto.InternalMessageInfo

func (m *VNFs) GetVnfs() []*VNF {
	if m != nil {
		return m.Vnfs
	}
	return nil
}

// TrafficPolicy is a policy that defines a set of traffic rules for the
// identified component (i.e. an application, an interface, etc.).
//
// A policy engine applies these rules, using the context of the identified
// component in order to send traffic to a target. The policy engine acts as
// a man-in-the-middle. It may modify the packets in order to facilitate the
// traffic flow. Examples of a policy engine are DPDK, VPP or iptables
// applications.
type TrafficPolicy struct {
	Id                   string         `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	TrafficRules         []*TrafficRule `protobuf:"bytes,2,rep,name=traffic_rules,json=trafficRules,proto3" json:"traffic_rules,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TrafficPolicy) Reset()         { *m = TrafficPolicy{} }
func (m *TrafficPolicy) String() string { return proto.CompactTextString(m) }
func (*TrafficPolicy) ProtoMessage()    {}
func (*TrafficPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{6}
}

func (m *TrafficPolicy) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TrafficPolicy.Unmarshal(m, b)
}
func (m *TrafficPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TrafficPolicy.Marshal(b, m, deterministic)
}
func (m *TrafficPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficPolicy.Merge(m, src)
}
func (m *TrafficPolicy) XXX_Size() int {
	return xxx_messageInfo_TrafficPolicy.Size(m)
}
func (m *TrafficPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficPolicy proto.InternalMessageInfo

func (m *TrafficPolicy) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TrafficPolicy) GetTrafficRules() []*TrafficRule {
	if m != nil {
		return m.TrafficRules
	}
	return nil
}

// TrafficRule defines a single traffic rule. The traffic selectors are used in
// order to construct both a rule that must be matched as well as what action
// to take on the traffic if the rule is matched.
//
// Since this is generic, the receiver of this rule must validate if the
// information provided by the caller is sufficient enough to construct a
// policy of a particular type.
//
// A single rule only allows one of each traffic selector to be specified.
// However, if a system supports advanced networking rules, a traffic rule can
// specify a subnet mask or a range in order to create a more dynamic rule.
//
// For example, a rule with a source selector of 10.20.30.0/24 could match all
// source traffic in that subnet block.
type TrafficRule struct {
	Description          string           `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Priority             uint32           `protobuf:"varint,2,opt,name=priority,proto3" json:"priority,omitempty"`
	Source               *TrafficSelector `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	Destination          *TrafficSelector `protobuf:"bytes,4,opt,name=destination,proto3" json:"destination,omitempty"`
	Target               *TrafficTarget   `protobuf:"bytes,5,opt,name=target,proto3" json:"target,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TrafficRule) Reset()         { *m = TrafficRule{} }
func (m *TrafficRule) String() string { return proto.CompactTextString(m) }
func (*TrafficRule) ProtoMessage()    {}
func (*TrafficRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{7}
}

func (m *TrafficRule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TrafficRule.Unmarshal(m, b)
}
func (m *TrafficRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TrafficRule.Marshal(b, m, deterministic)
}
func (m *TrafficRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficRule.Merge(m, src)
}
func (m *TrafficRule) XXX_Size() int {
	return xxx_messageInfo_TrafficRule.Size(m)
}
func (m *TrafficRule) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficRule.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficRule proto.InternalMessageInfo

func (m *TrafficRule) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *TrafficRule) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *TrafficRule) GetSource() *TrafficSelector {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *TrafficRule) GetDestination() *TrafficSelector {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *TrafficRule) GetTarget() *TrafficTarget {
	if m != nil {
		return m.Target
	}
	return nil
}

// TrafficSelector defines the parameters for a traffic selector in a
// TrafficRule. If a filter is empty, the selector does not evaluate it. The
// receiver can select traffic by using the filters as it is examining a packet
// or payload. They must filter using the OSI stack from layer 7 to layer 1.
// For example, if a MAC and IP are provided, the selector must first evaluate
// the IP (layer 3) before the MAC (layer 2).
//
// If a TrafficSelector has only the MAC filter specified, the selector is
// created only for that filter. However, if the selector contains a GTP and IP
// filter, the selector is created on both and the traffic must match both
// filters.
type TrafficSelector struct {
	Description          string     `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Macs                 *MACFilter `protobuf:"bytes,2,opt,name=macs,proto3" json:"macs,omitempty"`
	Ip                   *IPFilter  `protobuf:"bytes,3,opt,name=ip,proto3" json:"ip,omitempty"`
	Gtp                  *GTPFilter `protobuf:"bytes,4,opt,name=gtp,proto3" json:"gtp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *TrafficSelector) Reset()         { *m = TrafficSelector{} }
func (m *TrafficSelector) String() string { return proto.CompactTextString(m) }
func (*TrafficSelector) ProtoMessage()    {}
func (*TrafficSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{8}
}

func (m *TrafficSelector) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TrafficSelector.Unmarshal(m, b)
}
func (m *TrafficSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TrafficSelector.Marshal(b, m, deterministic)
}
func (m *TrafficSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficSelector.Merge(m, src)
}
func (m *TrafficSelector) XXX_Size() int {
	return xxx_messageInfo_TrafficSelector.Size(m)
}
func (m *TrafficSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficSelector.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficSelector proto.InternalMessageInfo

func (m *TrafficSelector) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *TrafficSelector) GetMacs() *MACFilter {
	if m != nil {
		return m.Macs
	}
	return nil
}

func (m *TrafficSelector) GetIp() *IPFilter {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *TrafficSelector) GetGtp() *GTPFilter {
	if m != nil {
		return m.Gtp
	}
	return nil
}

// MACFilter specifies properties related to MAC filters. Some implementations
// may not support multiple MAC addresses.
type MACFilter struct {
	MacAddresses         []string `protobuf:"bytes,1,rep,name=mac_addresses,json=macAddresses,proto3" json:"mac_addresses,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MACFilter) Reset()         { *m = MACFilter{} }
func (m *MACFilter) String() string { return proto.CompactTextString(m) }
func (*MACFilter) ProtoMessage()    {}
func (*MACFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{9}
}

func (m *MACFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MACFilter.Unmarshal(m, b)
}
func (m *MACFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MACFilter.Marshal(b, m, deterministic)
}
func (m *MACFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MACFilter.Merge(m, src)
}
func (m *MACFilter) XXX_Size() int {
	return xxx_messageInfo_MACFilter.Size(m)
}
func (m *MACFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_MACFilter.DiscardUnknown(m)
}

var xxx_messageInfo_MACFilter proto.InternalMessageInfo

func (m *MACFilter) GetMacAddresses() []string {
	if m != nil {
		return m.MacAddresses
	}
	return nil
}

// IPFilter specifies properties related to IP filters. Some implementations
// may not support multiple IP address (subnets) or have IPv6 support.
//
// If a caller wishes to define a single port, begin_port and end_port should
// be the same. For example, if the port is 3306, begin_port is 3306 and
// end_port is 3306. It is invalid to provide a begin_port that is greater than
// the end_port.
//
// Leaving the address and mask fields empty implies that all possible IP
// addresses are in the filter. Leaving these primitive datatypes empty
// defaults to the type's zero-value (as is the norm in protobuf). The
// following describes the behavior depending on how the fields are populated:
//  ___________________________________________________________________________
// |      Address      |      Mask      |               Result                |
// |   Zero-value ("") | Zero-value (0) |  All IPv4 (and IPv6, if supported)  |
// |    "0.0.0.0"      | Zero-value (0) |  All IPv4 only                      |
// |       "::"        | Zero-value (0) |  All IPv6 only (if supported)       |
// |    "1.2.3.4"      | Zero-value (0) |  Invalid                            |
// |   Zero-value ("") |       24       |  Invalid                            |
//  ___________________________________________________________________________
type IPFilter struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Mask                 uint32   `protobuf:"varint,2,opt,name=mask,proto3" json:"mask,omitempty"`
	BeginPort            uint32   `protobuf:"varint,3,opt,name=begin_port,json=beginPort,proto3" json:"begin_port,omitempty"`
	EndPort              uint32   `protobuf:"varint,4,opt,name=end_port,json=endPort,proto3" json:"end_port,omitempty"`
	Protocol             string   `protobuf:"bytes,5,opt,name=protocol,proto3" json:"protocol,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPFilter) Reset()         { *m = IPFilter{} }
func (m *IPFilter) String() string { return proto.CompactTextString(m) }
func (*IPFilter) ProtoMessage()    {}
func (*IPFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{10}
}

func (m *IPFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IPFilter.Unmarshal(m, b)
}
func (m *IPFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IPFilter.Marshal(b, m, deterministic)
}
func (m *IPFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPFilter.Merge(m, src)
}
func (m *IPFilter) XXX_Size() int {
	return xxx_messageInfo_IPFilter.Size(m)
}
func (m *IPFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_IPFilter.DiscardUnknown(m)
}

var xxx_messageInfo_IPFilter proto.InternalMessageInfo

func (m *IPFilter) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *IPFilter) GetMask() uint32 {
	if m != nil {
		return m.Mask
	}
	return 0
}

func (m *IPFilter) GetBeginPort() uint32 {
	if m != nil {
		return m.BeginPort
	}
	return 0
}

func (m *IPFilter) GetEndPort() uint32 {
	if m != nil {
		return m.EndPort
	}
	return 0
}

func (m *IPFilter) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

// GTPFilter specifies properties related to GTP filters. Some implementations
// may not support multiple addresses or multiple IMSIs.
type GTPFilter struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Mask                 uint32   `protobuf:"varint,2,opt,name=mask,proto3" json:"mask,omitempty"`
	Imsis                []string `protobuf:"bytes,3,rep,name=imsis,proto3" json:"imsis,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GTPFilter) Reset()         { *m = GTPFilter{} }
func (m *GTPFilter) String() string { return proto.CompactTextString(m) }
func (*GTPFilter) ProtoMessage()    {}
func (*GTPFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{11}
}

func (m *GTPFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GTPFilter.Unmarshal(m, b)
}
func (m *GTPFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GTPFilter.Marshal(b, m, deterministic)
}
func (m *GTPFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GTPFilter.Merge(m, src)
}
func (m *GTPFilter) XXX_Size() int {
	return xxx_messageInfo_GTPFilter.Size(m)
}
func (m *GTPFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_GTPFilter.DiscardUnknown(m)
}

var xxx_messageInfo_GTPFilter proto.InternalMessageInfo

func (m *GTPFilter) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *GTPFilter) GetMask() uint32 {
	if m != nil {
		return m.Mask
	}
	return 0
}

func (m *GTPFilter) GetImsis() []string {
	if m != nil {
		return m.Imsis
	}
	return nil
}

// TrafficTarget defines the parameters for a traffic target in a TrafficRule.
// The action indicates what target action to perform. If a modify field is
// empty, the target does not perform that type of modification.
//
// For example, if the target should modify the MAC address, then it should be
// provided in the message. The modifiers are currently only applicable if the
// interface is trying to modify the traffic, such as is the case with a
// breakout interface.
type TrafficTarget struct {
	Description          string                     `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Action               TrafficTarget_TargetAction `protobuf:"varint,2,opt,name=action,proto3,enum=openness.ela.TrafficTarget_TargetAction" json:"action,omitempty"`
	Mac                  *MACModifier               `protobuf:"bytes,3,opt,name=mac,proto3" json:"mac,omitempty"`
	Ip                   *IPModifier                `protobuf:"bytes,4,opt,name=ip,proto3" json:"ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *TrafficTarget) Reset()         { *m = TrafficTarget{} }
func (m *TrafficTarget) String() string { return proto.CompactTextString(m) }
func (*TrafficTarget) ProtoMessage()    {}
func (*TrafficTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{12}
}

func (m *TrafficTarget) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TrafficTarget.Unmarshal(m, b)
}
func (m *TrafficTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TrafficTarget.Marshal(b, m, deterministic)
}
func (m *TrafficTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficTarget.Merge(m, src)
}
func (m *TrafficTarget) XXX_Size() int {
	return xxx_messageInfo_TrafficTarget.Size(m)
}
func (m *TrafficTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficTarget.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficTarget proto.InternalMessageInfo

func (m *TrafficTarget) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *TrafficTarget) GetAction() TrafficTarget_TargetAction {
	if m != nil {
		return m.Action
	}
	return TrafficTarget_ACCEPT
}

func (m *TrafficTarget) GetMac() *MACModifier {
	if m != nil {
		return m.Mac
	}
	return nil
}

func (m *TrafficTarget) GetIp() *IPModifier {
	if m != nil {
		return m.Ip
	}
	return nil
}

// MACModifier defines the MAC properties that should be modified.
type MACModifier struct {
	MacAddress           string   `protobuf:"bytes,1,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MACModifier) Reset()         { *m = MACModifier{} }
func (m *MACModifier) String() string { return proto.CompactTextString(m) }
func (*MACModifier) ProtoMessage()    {}
func (*MACModifier) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{13}
}

func (m *MACModifier) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MACModifier.Unmarshal(m, b)
}
func (m *MACModifier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MACModifier.Marshal(b, m, deterministic)
}
func (m *MACModifier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MACModifier.Merge(m, src)
}
func (m *MACModifier) XXX_Size() int {
	return xxx_messageInfo_MACModifier.Size(m)
}
func (m *MACModifier) XXX_DiscardUnknown() {
	xxx_messageInfo_MACModifier.DiscardUnknown(m)
}

var xxx_messageInfo_MACModifier proto.InternalMessageInfo

func (m *MACModifier) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

// IPModifier defines the IP properties that should be modified
type IPModifier struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Port                 uint32   `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPModifier) Reset()         { *m = IPModifier{} }
func (m *IPModifier) String() string { return proto.CompactTextString(m) }
func (*IPModifier) ProtoMessage()    {}
func (*IPModifier) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{14}
}

func (m *IPModifier) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IPModifier.Unmarshal(m, b)
}
func (m *IPModifier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IPModifier.Marshal(b, m, deterministic)
}
func (m *IPModifier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPModifier.Merge(m, src)
}
func (m *IPModifier) XXX_Size() int {
	return xxx_messageInfo_IPModifier.Size(m)
}
func (m *IPModifier) XXX_DiscardUnknown() {
	xxx_messageInfo_IPModifier.DiscardUnknown(m)
}

var xxx_messageInfo_IPModifier proto.InternalMessageInfo

func (m *IPModifier) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *IPModifier) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// NetworkInterface defines a network interface available on the host.
// Interfaces are typically kernel interfaces by default, and can be changed if
// the caller wishes to do so.
//
// The interface's type assists the policy engine in determining what types of
// traffic the interface can expect to be handling, and is mainly here for
// support of legacy implementations (which may require the field is updated in
// order to work properly).
//
// An interface can belong to multiple zones, which can be useful for when
// the amount of actual interfaces is limited.
type NetworkInterface struct {
	Id          string                           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Description string                           `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Driver      NetworkInterface_InterfaceDriver `protobuf:"varint,3,opt,name=driver,proto3,enum=openness.ela.NetworkInterface_InterfaceDriver" json:"driver,omitempty"`
	Type        NetworkInterface_InterfaceType   `protobuf:"varint,4,opt,name=type,proto3,enum=openness.ela.NetworkInterface_InterfaceType" json:"type,omitempty"`
	MacAddress  string                           `protobuf:"bytes,5,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	Vlan        uint32                           `protobuf:"varint,6,opt,name=vlan,proto3" json:"vlan,omitempty"`
	Zones       []string                         `protobuf:"bytes,7,rep,name=zones,proto3" json:"zones,omitempty"`
	// (LEGACY) The fallback interface for this interface. This only exists for
	// legacy dataplane implementations. In future implementations, a traffic
	// policy should be used to yield the same results. Using this is not
	// advisable as it belongs in the traffic policy and exposes a fallback
	// behavior that can be seen as insecure.
	FallbackInterface    string   `protobuf:"bytes,8,opt,name=fallback_interface,json=fallbackInterface,proto3" json:"fallback_interface,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkInterface) Reset()         { *m = NetworkInterface{} }
func (m *NetworkInterface) String() string { return proto.CompactTextString(m) }
func (*NetworkInterface) ProtoMessage()    {}
func (*NetworkInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{15}
}

func (m *NetworkInterface) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkInterface.Unmarshal(m, b)
}
func (m *NetworkInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkInterface.Marshal(b, m, deterministic)
}
func (m *NetworkInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInterface.Merge(m, src)
}
func (m *NetworkInterface) XXX_Size() int {
	return xxx_messageInfo_NetworkInterface.Size(m)
}
func (m *NetworkInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInterface.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInterface proto.InternalMessageInfo

func (m *NetworkInterface) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NetworkInterface) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *NetworkInterface) GetDriver() NetworkInterface_InterfaceDriver {
	if m != nil {
		return m.Driver
	}
	return NetworkInterface_KERNEL
}

func (m *NetworkInterface) GetType() NetworkInterface_InterfaceType {
	if m != nil {
		return m.Type
	}
	return NetworkInterface_NONE
}

func (m *NetworkInterface) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *NetworkInterface) GetVlan() uint32 {
	if m != nil {
		return m.Vlan
	}
	return 0
}

func (m *NetworkInterface) GetZones() []string {
	if m != nil {
		return m.Zones
	}
	return nil
}

func (m *NetworkInterface) GetFallbackInterface() string {
	if m != nil {
		return m.FallbackInterface
	}
	return ""
}

type NetworkInterfaces struct {
	NetworkInterfaces    []*NetworkInterface `protobuf:"bytes,1,rep,name=network_interfaces,json=networkInterfaces,proto3" json:"network_interfaces,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *NetworkInterfaces) Reset()         { *m = NetworkInterfaces{} }
func (m *NetworkInterfaces) String() string { return proto.CompactTextString(m) }
func (*NetworkInterfaces) ProtoMessage()    {}
func (*NetworkInterfaces) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{16}
}

func (m *NetworkInterfaces) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkInterfaces.Unmarshal(m, b)
}
func (m *NetworkInterfaces) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkInterfaces.Marshal(b, m, deterministic)
}
func (m *NetworkInterfaces) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInterfaces.Merge(m, src)
}
func (m *NetworkInterfaces) XXX_Size() int {
	return xxx_messageInfo_NetworkInterfaces.Size(m)
}
func (m *NetworkInterfaces) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInterfaces.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInterfaces proto.InternalMessageInfo

func (m *NetworkInterfaces) GetNetworkInterfaces() []*NetworkInterface {
	if m != nil {
		return m.NetworkInterfaces
	}
	return nil
}

// NetworkZone defines a network zone. A zone is effectively a label that
// isolates network traffic within an appliance. It allows for further rules
// to be made surrounding the zone and interfaces that are assigned to it.
type NetworkZone struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Description          string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkZone) Reset()         { *m = NetworkZone{} }
func (m *NetworkZone) String() string { return proto.CompactTextString(m) }
func (*NetworkZone) ProtoMessage()    {}
func (*NetworkZone) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{17}
}

func (m *NetworkZone) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkZone.Unmarshal(m, b)
}
func (m *NetworkZone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkZone.Marshal(b, m, deterministic)
}
func (m *NetworkZone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkZone.Merge(m, src)
}
func (m *NetworkZone) XXX_Size() int {
	return xxx_messageInfo_NetworkZone.Size(m)
}
func (m *NetworkZone) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkZone.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkZone proto.InternalMessageInfo

func (m *NetworkZone) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NetworkZone) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type NetworkZones struct {
	NetworkZones         []*NetworkZone `protobuf:"bytes,1,rep,name=network_zones,json=networkZones,proto3" json:"network_zones,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *NetworkZones) Reset()         { *m = NetworkZones{} }
func (m *NetworkZones) String() string { return proto.CompactTextString(m) }
func (*NetworkZones) ProtoMessage()    {}
func (*NetworkZones) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{18}
}

func (m *NetworkZones) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkZones.Unmarshal(m, b)
}
func (m *NetworkZones) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkZones.Marshal(b, m, deterministic)
}
func (m *NetworkZones) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkZones.Merge(m, src)
}
func (m *NetworkZones) XXX_Size() int {
	return xxx_messageInfo_NetworkZones.Size(m)
}
func (m *NetworkZones) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkZones.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkZones proto.InternalMessageInfo

func (m *NetworkZones) GetNetworkZones() []*NetworkZone {
	if m != nil {
		return m.NetworkZones
	}
	return nil
}

// NetworkSetting defines a network setting. It can be included in an interface
// to configure it's IP properties.
type NetworkSetting struct {
	Status               NetworkSetting_Status `protobuf:"varint,1,opt,name=status,proto3,enum=openness.ela.NetworkSetting_Status" json:"status,omitempty"`
	Address              string                `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Mask                 uint32                `protobuf:"varint,3,opt,name=mask,proto3" json:"mask,omitempty"`
	Gateway              string                `protobuf:"bytes,4,opt,name=gateway,proto3" json:"gateway,omitempty"`
	Dns                  []string              `protobuf:"bytes,5,rep,name=dns,proto3" json:"dns,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *NetworkSetting) Reset()         { *m = NetworkSetting{} }
func (m *NetworkSetting) String() string { return proto.CompactTextString(m) }
func (*NetworkSetting) ProtoMessage()    {}
func (*NetworkSetting) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{19}
}

func (m *NetworkSetting) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkSetting.Unmarshal(m, b)
}
func (m *NetworkSetting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkSetting.Marshal(b, m, deterministic)
}
func (m *NetworkSetting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkSetting.Merge(m, src)
}
func (m *NetworkSetting) XXX_Size() int {
	return xxx_messageInfo_NetworkSetting.Size(m)
}
func (m *NetworkSetting) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkSetting.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkSetting proto.InternalMessageInfo

func (m *NetworkSetting) GetStatus() NetworkSetting_Status {
	if m != nil {
		return m.Status
	}
	return NetworkSetting_NONE
}

func (m *NetworkSetting) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *NetworkSetting) GetMask() uint32 {
	if m != nil {
		return m.Mask
	}
	return 0
}

func (m *NetworkSetting) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

func (m *NetworkSetting) GetDns() []string {
	if m != nil {
		return m.Dns
	}
	return nil
}

// DNSForwarders represents the upstream DNS forwarders, which may be used when
// the DNS services is performing a recursive lookup. Forwarders should be
// utilized when more advanced DNS usage is desired.
type DNSForwarders struct {
	IpAddresses          []string `protobuf:"bytes,1,rep,name=ip_addresses,json=ipAddresses,proto3" json:"ip_addresses,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DNSForwarders) Reset()         { *m = DNSForwarders{} }
func (m *DNSForwarders) String() string { return proto.CompactTextString(m) }
func (*DNSForwarders) ProtoMessage()    {}
func (*DNSForwarders) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{20}
}

func (m *DNSForwarders) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DNSForwarders.Unmarshal(m, b)
}
func (m *DNSForwarders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DNSForwarders.Marshal(b, m, deterministic)
}
func (m *DNSForwarders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSForwarders.Merge(m, src)
}
func (m *DNSForwarders) XXX_Size() int {
	return xxx_messageInfo_DNSForwarders.Size(m)
}
func (m *DNSForwarders) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSForwarders.DiscardUnknown(m)
}

var xxx_messageInfo_DNSForwarders proto.InternalMessageInfo

func (m *DNSForwarders) GetIpAddresses() []string {
	if m != nil {
		return m.IpAddresses
	}
	return nil
}

// DNSARecordSet contains one or more values for a name, which is a fully
// qualified domain name (FQDN). The values are typically either an ID for
// the record (such as an application ID or a VNF ID) or an IP address.
type DNSARecordSet struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Values               []string `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DNSARecordSet) Reset()         { *m = DNSARecordSet{} }
func (m *DNSARecordSet) String() string { return proto.CompactTextString(m) }
func (*DNSARecordSet) ProtoMessage()    {}
func (*DNSARecordSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{21}
}

func (m *DNSARecordSet) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DNSARecordSet.Unmarshal(m, b)
}
func (m *DNSARecordSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DNSARecordSet.Marshal(b, m, deterministic)
}
func (m *DNSARecordSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSARecordSet.Merge(m, src)
}
func (m *DNSARecordSet) XXX_Size() int {
	return xxx_messageInfo_DNSARecordSet.Size(m)
}
func (m *DNSARecordSet) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSARecordSet.DiscardUnknown(m)
}

var xxx_messageInfo_DNSARecordSet proto.InternalMessageInfo

func (m *DNSARecordSet) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DNSARecordSet) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

type ApplicationID struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ApplicationID) Reset()         { *m = ApplicationID{} }
func (m *ApplicationID) String() string { return proto.CompactTextString(m) }
func (*ApplicationID) ProtoMessage()    {}
func (*ApplicationID) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{22}
}

func (m *ApplicationID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ApplicationID.Unmarshal(m, b)
}
func (m *ApplicationID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ApplicationID.Marshal(b, m, deterministic)
}
func (m *ApplicationID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationID.Merge(m, src)
}
func (m *ApplicationID) XXX_Size() int {
	return xxx_messageInfo_ApplicationID.Size(m)
}
func (m *ApplicationID) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationID.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationID proto.InternalMessageInfo

func (m *ApplicationID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type InterfaceID struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InterfaceID) Reset()         { *m = InterfaceID{} }
func (m *InterfaceID) String() string { return proto.CompactTextString(m) }
func (*InterfaceID) ProtoMessage()    {}
func (*InterfaceID) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{23}
}

func (m *InterfaceID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InterfaceID.Unmarshal(m, b)
}
func (m *InterfaceID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InterfaceID.Marshal(b, m, deterministic)
}
func (m *InterfaceID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceID.Merge(m, src)
}
func (m *InterfaceID) XXX_Size() int {
	return xxx_messageInfo_InterfaceID.Size(m)
}
func (m *InterfaceID) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceID.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceID proto.InternalMessageInfo

func (m *InterfaceID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type VNFID struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VNFID) Reset()         { *m = VNFID{} }
func (m *VNFID) String() string { return proto.CompactTextString(m) }
func (*VNFID) ProtoMessage()    {}
func (*VNFID) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{24}
}

func (m *VNFID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VNFID.Unmarshal(m, b)
}
func (m *VNFID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VNFID.Marshal(b, m, deterministic)
}
func (m *VNFID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VNFID.Merge(m, src)
}
func (m *VNFID) XXX_Size() int {
	return xxx_messageInfo_VNFID.Size(m)
}
func (m *VNFID) XXX_DiscardUnknown() {
	xxx_messageInfo_VNFID.DiscardUnknown(m)
}

var xxx_messageInfo_VNFID proto.InternalMessageInfo

func (m *VNFID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type ZoneID struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ZoneID) Reset()         { *m = ZoneID{} }
func (m *ZoneID) String() string { return proto.CompactTextString(m) }
func (*ZoneID) ProtoMessage()    {}
func (*ZoneID) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb26205266db6e19, []int{25}
}

func (m *ZoneID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ZoneID.Unmarshal(m, b)
}
func (m *ZoneID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ZoneID.Marshal(b, m, deterministic)
}
func (m *ZoneID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZoneID.Merge(m, src)
}
func (m *ZoneID) XXX_Size() int {
	return xxx_messageInfo_ZoneID.Size(m)
}
func (m *ZoneID) XXX_DiscardUnknown() {
	xxx_messageInfo_ZoneID.DiscardUnknown(m)
}

var xxx_messageInfo_ZoneID proto.InternalMessageInfo

func (m *ZoneID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func init() {
	proto.RegisterEnum("openness.ela.LifecycleCommand_Command", LifecycleCommand_Command_name, LifecycleCommand_Command_value)
	proto.RegisterEnum("openness.ela.LifecycleStatus_Status", LifecycleStatus_Status_name, LifecycleStatus_Status_value)
	proto.RegisterEnum("openness.ela.TrafficTarget_TargetAction", TrafficTarget_TargetAction_name, TrafficTarget_TargetAction_value)
	proto.RegisterEnum("openness.ela.NetworkInterface_InterfaceDriver", NetworkInterface_InterfaceDriver_name, NetworkInterface_InterfaceDriver_value)
	proto.RegisterEnum("openness.ela.NetworkInterface_InterfaceType", NetworkInterface_InterfaceType_name, NetworkInterface_InterfaceType_value)
	proto.RegisterEnum("openness.ela.NetworkSetting_Status", NetworkSetting_Status_name, NetworkSetting_Status_value)
	proto.RegisterType((*LifecycleCommand)(nil), "openness.ela.LifecycleCommand")
	proto.RegisterType((*LifecycleStatus)(nil), "openness.ela.LifecycleStatus")
	proto.RegisterType((*Application)(nil), "openness.ela.Application")
	proto.RegisterType((*Applications)(nil), "openness.ela.Applications")
	proto.RegisterType((*VNF)(nil), "openness.ela.VNF")
	proto.RegisterType((*VNFs)(nil), "openness.ela.VNFs")
	proto.RegisterType((*TrafficPolicy)(nil), "openness.ela.TrafficPolicy")
	proto.RegisterType((*TrafficRule)(nil), "openness.ela.TrafficRule")
	proto.RegisterType((*TrafficSelector)(nil), "openness.ela.TrafficSelector")
	proto.RegisterType((*MACFilter)(nil), "openness.ela.MACFilter")
	proto.RegisterType((*IPFilter)(nil), "openness.ela.IPFilter")
	proto.RegisterType((*GTPFilter)(nil), "openness.ela.GTPFilter")
	proto.RegisterType((*TrafficTarget)(nil), "openness.ela.TrafficTarget")
	proto.RegisterType((*MACModifier)(nil), "openness.ela.MACModifier")
	proto.RegisterType((*IPModifier)(nil), "openness.ela.IPModifier")
	proto.RegisterType((*NetworkInterface)(nil), "openness.ela.NetworkInterface")
	proto.RegisterType((*NetworkInterfaces)(nil), "openness.ela.NetworkInterfaces")
	proto.RegisterType((*NetworkZone)(nil), "openness.ela.NetworkZone")
	proto.RegisterType((*NetworkZones)(nil), "openness.ela.NetworkZones")
	proto.RegisterType((*NetworkSetting)(nil), "openness.ela.NetworkSetting")
	proto.RegisterType((*DNSForwarders)(nil), "openness.ela.DNSForwarders")
	proto.RegisterType((*DNSARecordSet)(nil), "openness.ela.DNSARecordSet")
	proto.RegisterType((*ApplicationID)(nil), "openness.ela.ApplicationID")
	proto.RegisterType((*InterfaceID)(nil), "openness.ela.InterfaceID")
	proto.RegisterType((*VNFID)(nil), "openness.ela.VNFID")
	proto.RegisterType((*ZoneID)(nil), "openness.ela.ZoneID")
}

func init() { proto.RegisterFile("ela.proto", fileDescriptor_eb26205266db6e19) }

var fileDescriptor_eb26205266db6e19 = []byte{
	// 3017 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x59, 0x4d, 0x6c, 0xe3, 0xd6,
	0x9d, 0xcf, 0x93, 0x6c, 0xd9, 0xfe, 0xcb, 0xf2, 0x68, 0xde, 0xf8, 0x43, 0x43, 0xdb, 0x33, 0x1c,
	0x7a, 0x32, 0x71, 0xe6, 0x43, 0x72, 0x38, 0x4e, 0x36, 0x3b, 0x49, 0x36, 0xc3, 0x91, 0x64, 0xaf,
	0x1d, 0x5b, 0xf6, 0x52, 0xb6, 0xf3, 0x75, 0x98, 0xa5, 0xa9, 0x67, 0x0d, 0x77, 0x24, 0x92, 0x20,
	0x29, 0xcf, 0x3a, 0xc1, 0x6e, 0x90, 0x16, 0x19, 0xa0, 0x3d, 0xb4, 0x81, 0x02, 0x14, 0x29, 0xda,
	0xa6, 0x28, 0x52, 0x14, 0xe8, 0xa1, 0x87, 0xa2, 0x68, 0xd1, 0xde, 0x9a, 0x1e, 0xda, 0xa2, 0xa7,
	0xa2, 0xbd, 0x15, 0x3d, 0xb6, 0x40, 0x51, 0xa0, 0xf7, 0x02, 0xe9, 0xa1, 0x78, 0xef, 0x51, 0x12,
	0x49, 0x89, 0x9e, 0x19, 0xfb, 0xd6, 0x93, 0xf8, 0xf8, 0xff, 0x78, 0xbf, 0xff, 0xf7, 0x7b, 0x14,
	0x8c, 0x91, 0x86, 0x96, 0xb7, 0x1d, 0xcb, 0xb3, 0xf0, 0xb8, 0x65, 0x13, 0xd3, 0x24, 0xae, 0x9b,
	0x27, 0x0d, 0x4d, 0x98, 0xad, 0x5b, 0x56, 0xbd, 0x41, 0x0a, 0x8c, 0xb6, 0xdf, 0x3a, 0x28, 0x90,
	0xa6, 0xed, 0x1d, 0x71, 0x56, 0x61, 0xce, 0x27, 0x6a, 0xb6, 0x51, 0xd0, 0x4c, 0xd3, 0xf2, 0x34,
	0xcf, 0xb0, 0x4c, 0xd7, 0xa7, 0x5e, 0x67, 0x3f, 0xfa, 0x8d, 0x3a, 0x31, 0x6f, 0xb8, 0x0f, 0xb4,
	0x7a, 0x9d, 0x38, 0x05, 0xcb, 0x66, 0x1c, 0xfd, 0xdc, 0xd2, 0x97, 0x10, 0x64, 0x37, 0x8c, 0x03,
	0xa2, 0x1f, 0xe9, 0x0d, 0x52, 0xb4, 0x9a, 0x4d, 0xcd, 0xac, 0xe1, 0x09, 0x48, 0x18, 0xb5, 0x1c,
	0x12, 0xd1, 0xe2, 0x98, 0x9a, 0x30, 0x6a, 0xf8, 0x45, 0x48, 0xea, 0xcd, 0x5a, 0x2e, 0x21, 0xa2,
	0xc5, 0x09, 0xf9, 0x4a, 0x3e, 0x88, 0x34, 0x1f, 0x15, 0xce, 0xfb, 0xbf, 0x2a, 0x15, 0x91, 0xae,
	0xc1, 0x48, 0x47, 0xe9, 0x18, 0x0c, 0x57, 0x77, 0x14, 0x75, 0x27, 0xfb, 0x14, 0x1e, 0x85, 0xa1,
	0xea, 0xce, 0xd6, 0x76, 0x16, 0xe1, 0x34, 0x8c, 0xa8, 0x65, 0xfe, 0x3a, 0x21, 0x7d, 0x86, 0xe0,
	0x4c, 0x57, 0x5d, 0xd5, 0xd3, 0xbc, 0x96, 0x8b, 0x5f, 0x86, 0x94, 0xcb, 0x9e, 0x18, 0x9c, 0x09,
	0xf9, 0x72, 0xcc, 0xee, 0x9c, 0x3d, 0xcf, 0x7f, 0x54, 0x5f, 0x46, 0xb2, 0x21, 0xe5, 0xeb, 0x49,
	0xc3, 0xc8, 0x6e, 0xe5, 0xb5, 0xca, 0xd6, 0xeb, 0x95, 0xec, 0x53, 0x38, 0x03, 0x63, 0xa5, 0xf2,
	0xf6, 0xc6, 0xd6, 0x9b, 0x6b, 0x95, 0xd5, 0x2c, 0xa2, 0xc8, 0xd4, 0xb2, 0x52, 0x7a, 0x33, 0x9b,
	0xc0, 0xe3, 0x30, 0xca, 0xd0, 0x50, 0x42, 0x92, 0xa1, 0xdb, 0xad, 0x54, 0xe8, 0x62, 0x88, 0x93,
	0xb6, 0xb6, 0xb7, 0xe9, 0x6a, 0x98, 0x92, 0xd8, 0xaa, 0x5c, 0xca, 0xa6, 0xa8, 0x82, 0xb2, 0xaa,
	0x6e, 0xa9, 0xd9, 0x11, 0xe9, 0x6f, 0x08, 0xd2, 0x8a, 0x6d, 0x37, 0x0c, 0x9d, 0xb9, 0xb9, 0xcf,
	0x95, 0x18, 0x86, 0x4c, 0xad, 0x49, 0x98, 0x2f, 0xc7, 0x54, 0xf6, 0x8c, 0xa7, 0x21, 0x75, 0x48,
	0xcc, 0x9a, 0xe5, 0xe4, 0x92, 0xec, 0xad, 0xbf, 0xc2, 0x22, 0xa4, 0x6b, 0xc4, 0xd5, 0x1d, 0x83,
	0x45, 0x2f, 0x37, 0xc4, 0x88, 0xc1, 0x57, 0x78, 0x12, 0x86, 0x8d, 0xa6, 0x56, 0x27, 0xb9, 0x61,
	0x46, 0xe3, 0x0b, 0xfa, 0x56, 0xb7, 0x1c, 0xe2, 0xe6, 0x52, 0x22, 0x5a, 0x1c, 0x56, 0xf9, 0x82,
	0xee, 0xd2, 0x24, 0x4d, 0xcb, 0x39, 0xca, 0x8d, 0xb0, 0xd7, 0xfe, 0x2a, 0xe0, 0xe1, 0xd1, 0x13,
	0x78, 0x78, 0x13, 0xc6, 0x03, 0xe6, 0xba, 0xf8, 0x15, 0x18, 0xd7, 0x02, 0xeb, 0x1c, 0x12, 0x93,
	0x8b, 0x69, 0xf9, 0x7c, 0x58, 0x67, 0x40, 0x42, 0x0d, 0xb1, 0x4b, 0x7f, 0x46, 0x90, 0xdc, 0xab,
	0xac, 0xfc, 0xcb, 0xbb, 0xed, 0x06, 0x0c, 0xed, 0x55, 0x56, 0x5c, 0xfc, 0x34, 0x0c, 0x1d, 0x9a,
	0x07, 0x1d, 0x37, 0x9d, 0x0d, 0xeb, 0xd8, 0xab, 0xac, 0xa8, 0x8c, 0x2c, 0xdd, 0x85, 0xcc, 0x8e,
	0xa3, 0x1d, 0x1c, 0x18, 0xfa, 0xb6, 0xd5, 0x30, 0xf4, 0xa3, 0x3e, 0xff, 0xfc, 0x07, 0x64, 0x3c,
	0xce, 0x70, 0xd7, 0x69, 0x35, 0x88, 0x9b, 0x4b, 0x0c, 0xf2, 0xbb, 0xaf, 0x43, 0x6d, 0x35, 0x88,
	0x3a, 0xee, 0xf5, 0x16, 0xae, 0xf4, 0x77, 0x04, 0xe9, 0x00, 0x35, 0xea, 0x43, 0xd4, 0xef, 0x43,
	0x01, 0x46, 0x6d, 0xc7, 0xb0, 0x1c, 0xc3, 0x3b, 0x62, 0x51, 0xc9, 0xa8, 0xdd, 0x35, 0x7e, 0x1e,
	0x52, 0xae, 0xd5, 0x72, 0x74, 0xc2, 0x22, 0x93, 0x96, 0xe7, 0x07, 0xc2, 0xa8, 0x92, 0x06, 0xd1,
	0x3d, 0xcb, 0x51, 0x7d, 0x66, 0xfc, 0x2a, 0xdb, 0xd4, 0x33, 0x4c, 0xad, 0x1b, 0xb8, 0x47, 0xca,
	0x06, 0x25, 0xf0, 0x4d, 0x48, 0x79, 0x9a, 0x53, 0x27, 0x1e, 0x0b, 0x6c, 0x5a, 0x9e, 0x1d, 0x28,
	0xbb, 0xc3, 0x58, 0x54, 0x9f, 0x55, 0xfa, 0x11, 0x82, 0x33, 0x11, 0xad, 0x8f, 0x61, 0xfe, 0x35,
	0x18, 0x6a, 0x6a, 0xba, 0xcb, 0x4c, 0x4f, 0xcb, 0x33, 0xe1, 0x8d, 0x36, 0x95, 0xe2, 0x8a, 0xd1,
	0xf0, 0x88, 0xa3, 0x32, 0x26, 0x7c, 0x05, 0x12, 0x86, 0xed, 0xfb, 0x62, 0x3a, 0xcc, 0xba, 0xb6,
	0xed, 0x73, 0x26, 0x0c, 0x1b, 0x3f, 0x0b, 0xc9, 0xba, 0x67, 0xfb, 0x86, 0x47, 0x74, 0xae, 0xee,
	0x74, 0x38, 0x29, 0x8f, 0xb4, 0x04, 0x63, 0xdd, 0x5d, 0xf0, 0x02, 0x64, 0x9a, 0x9a, 0x7e, 0x57,
	0xab, 0xd5, 0x1c, 0xe2, 0xba, 0x84, 0xa7, 0xd3, 0x98, 0x3a, 0xde, 0xd4, 0x74, 0xa5, 0xf3, 0x4e,
	0xfa, 0x0a, 0x82, 0xd1, 0xce, 0x6e, 0x38, 0x07, 0x23, 0x3e, 0xb7, 0x6f, 0x5c, 0x67, 0x49, 0x2b,
	0xad, 0xa9, 0xb9, 0xf7, 0xfd, 0x98, 0xb2, 0x67, 0x3c, 0x0f, 0xb0, 0x4f, 0xea, 0x86, 0x79, 0xd7,
	0xb6, 0x1c, 0x8f, 0xd9, 0x91, 0x51, 0xc7, 0xd8, 0x9b, 0x6d, 0xcb, 0xf1, 0xf0, 0x79, 0x18, 0x25,
	0x66, 0x8d, 0x13, 0x87, 0x18, 0x71, 0x84, 0x98, 0x35, 0x46, 0x62, 0x59, 0x42, 0xc7, 0x91, 0xd5,
	0xf0, 0x8b, 0xad, 0xbb, 0x96, 0xb6, 0x60, 0xac, 0x6b, 0xd4, 0x13, 0x02, 0x62, 0x05, 0xec, 0x1a,
	0x6e, 0x2e, 0xc9, 0x0c, 0xe5, 0x0b, 0xe9, 0x1f, 0xa8, 0x5b, 0x26, 0x3c, 0xc6, 0x8f, 0x11, 0xc7,
	0xdb, 0x90, 0xd2, 0x74, 0x46, 0xe4, 0xd3, 0x6d, 0xf1, 0x98, 0x94, 0xc9, 0xf3, 0x1f, 0x85, 0xf1,
	0xab, 0xbe, 0x1c, 0xbe, 0x06, 0xc9, 0xa6, 0xa6, 0xfb, 0xd1, 0x3d, 0xdf, 0x97, 0x08, 0x9b, 0x56,
	0xcd, 0x38, 0x30, 0x68, 0xd8, 0x9a, 0x9a, 0x8e, 0x17, 0x59, 0x26, 0xf0, 0x00, 0xe7, 0xa2, 0x99,
	0xd0, 0x65, 0x4d, 0x18, 0x34, 0xc0, 0xe3, 0xc1, 0xed, 0x30, 0x40, 0x4a, 0x29, 0x16, 0xcb, 0xdb,
	0x74, 0x7e, 0x02, 0xa4, 0xd4, 0xf2, 0x7a, 0xb9, 0xb8, 0x93, 0x45, 0x74, 0x96, 0x96, 0xd4, 0xad,
	0xed, 0x6c, 0x42, 0xca, 0x43, 0x3a, 0xb0, 0x1f, 0xbe, 0x08, 0xe9, 0x40, 0x52, 0xf8, 0xb6, 0x43,
	0x2f, 0x25, 0xa4, 0x5b, 0x00, 0xbd, 0x3d, 0x8f, 0x0f, 0x00, 0x0b, 0xad, 0x1f, 0x00, 0xfa, 0x2c,
	0xfd, 0x36, 0x09, 0xd9, 0x0a, 0xf1, 0x1e, 0x58, 0xce, 0xfd, 0x35, 0xd3, 0x23, 0xce, 0x81, 0xa6,
	0x93, 0xbe, 0xa6, 0x14, 0xf1, 0x7e, 0xa2, 0xdf, 0xfb, 0x2b, 0x90, 0xaa, 0x39, 0xc6, 0x21, 0xe1,
	0x2d, 0x7c, 0x42, 0xce, 0x87, 0x5d, 0x12, 0xdd, 0x21, 0xdf, 0x7d, 0x2a, 0x31, 0x29, 0xd5, 0x97,
	0xc6, 0xb7, 0x61, 0xc8, 0x3b, 0xb2, 0x09, 0x73, 0xec, 0x84, 0x7c, 0xfd, 0x71, 0xb5, 0xec, 0x1c,
	0xd9, 0x44, 0x65, 0x92, 0x51, 0x6f, 0x0d, 0x47, 0xbd, 0x45, 0xbd, 0x70, 0xd8, 0xd0, 0x4c, 0x36,
	0x1c, 0x32, 0x2a, 0x7b, 0xa6, 0x69, 0xf8, 0x8e, 0x65, 0x12, 0x37, 0x37, 0xc2, 0xd3, 0x90, 0x2d,
	0xf0, 0x0d, 0xc0, 0x07, 0x5a, 0xa3, 0xb1, 0xaf, 0xe9, 0xf7, 0xef, 0x1a, 0x9d, 0xad, 0xd8, 0x94,
	0x18, 0x53, 0xcf, 0x76, 0x28, 0x5d, 0x0c, 0xd2, 0x75, 0x38, 0x13, 0x31, 0x8b, 0xc6, 0xf7, 0xb5,
	0xb2, 0x5a, 0x29, 0x6f, 0xf0, 0xb3, 0xca, 0x6e, 0xb5, 0xac, 0x56, 0xb7, 0x95, 0x62, 0x39, 0x8b,
	0xa4, 0x37, 0x20, 0x13, 0x82, 0x4f, 0xe3, 0x5f, 0xd9, 0xaa, 0x94, 0xb3, 0x4f, 0xd1, 0x03, 0xca,
	0xee, 0x76, 0x75, 0x47, 0x2d, 0x2b, 0x9b, 0x59, 0x84, 0x27, 0x00, 0x4a, 0x5b, 0xaf, 0x57, 0xfc,
	0x75, 0x02, 0x9f, 0x85, 0xcc, 0x9d, 0xb5, 0xd2, 0x9a, 0x5a, 0x2e, 0xee, 0xac, 0x6d, 0x55, 0x94,
	0x8d, 0x6c, 0x92, 0x0a, 0xdc, 0x51, 0xcb, 0xca, 0x6b, 0x5b, 0xbb, 0x3b, 0xd9, 0x21, 0x69, 0x1f,
	0xce, 0x46, 0x3d, 0xe5, 0xe2, 0x4d, 0xc0, 0x26, 0x7f, 0xd9, 0x33, 0xa5, 0x33, 0xad, 0x2e, 0x1c,
	0xef, 0x66, 0xf5, 0xac, 0x19, 0x55, 0x27, 0xbd, 0x0a, 0x69, 0x9f, 0xed, 0x2d, 0xcb, 0x3c, 0x41,
	0xc2, 0x48, 0x15, 0x18, 0x0f, 0x28, 0x70, 0xe9, 0xdc, 0xeb, 0xe0, 0xe3, 0x91, 0x18, 0x78, 0xde,
	0x08, 0x88, 0xa8, 0xe3, 0x66, 0x40, 0x5e, 0xfa, 0x2b, 0x82, 0x09, 0x9f, 0x5a, 0x25, 0x9e, 0x67,
	0x98, 0x75, 0xfc, 0x52, 0xe4, 0xc4, 0xb9, 0x30, 0x50, 0x97, 0xcf, 0x1d, 0x99, 0xeb, 0xc1, 0x2a,
	0x4a, 0x0c, 0x6e, 0x63, 0xc9, 0x40, 0x1b, 0xcb, 0xc1, 0x48, 0x5d, 0xf3, 0xc8, 0x03, 0xed, 0xc8,
	0x3f, 0xa5, 0x74, 0x96, 0x38, 0x0b, 0xc9, 0x9a, 0x49, 0xd3, 0x90, 0xe6, 0x15, 0x7d, 0x94, 0x94,
	0xee, 0x51, 0xb6, 0x17, 0x71, 0x80, 0x54, 0x75, 0x47, 0xd9, 0x59, 0x2b, 0x66, 0x11, 0x7d, 0x2e,
	0xfd, 0x67, 0x71, 0xfb, 0x70, 0x39, 0x9b, 0xe8, 0x3e, 0xbf, 0x90, 0x4d, 0xb2, 0x63, 0xf7, 0x86,
	0xa2, 0x14, 0xb3, 0x43, 0x92, 0x0c, 0x99, 0x52, 0xa5, 0xba, 0x62, 0x39, 0x0f, 0x34, 0xa7, 0x46,
	0x1c, 0x17, 0x5f, 0x82, 0x71, 0xc3, 0xee, 0x1b, 0x1b, 0x69, 0xc3, 0xee, 0x4d, 0x8d, 0x97, 0x98,
	0x8c, 0xa2, 0x12, 0xdd, 0x72, 0x6a, 0x55, 0xe2, 0x75, 0x4f, 0x62, 0x28, 0x72, 0x12, 0xd3, 0x1a,
	0x2d, 0xff, 0xd8, 0x41, 0x4f, 0x62, 0x6c, 0x25, 0x5d, 0x84, 0x4c, 0xe0, 0xa8, 0xb7, 0x56, 0x8a,
	0x06, 0x5c, 0x9a, 0x87, 0x74, 0x37, 0x3b, 0x06, 0x90, 0x67, 0x60, 0x78, 0xaf, 0xb2, 0x32, 0x80,
	0x90, 0x83, 0x14, 0x8d, 0x5f, 0x3f, 0x45, 0x7e, 0x38, 0x0a, 0x73, 0x81, 0x3d, 0x4b, 0xc4, 0x6e,
	0x58, 0x47, 0x4d, 0x62, 0x7a, 0x55, 0xe2, 0x1c, 0x1a, 0x3a, 0xc1, 0x3f, 0x41, 0x70, 0x86, 0xbf,
	0x2d, 0x5a, 0xa6, 0xa7, 0x19, 0x26, 0x71, 0x70, 0xfc, 0xf1, 0x54, 0x98, 0xce, 0xf3, 0xcb, 0x56,
	0xbe, 0x73, 0x13, 0xcb, 0x97, 0xe9, 0x4d, 0x4c, 0xb2, 0xdb, 0xca, 0xae, 0x70, 0x81, 0x2b, 0x12,
	0x35, 0x51, 0xef, 0xe8, 0x12, 0x03, 0xc7, 0xd9, 0xf5, 0x9b, 0x90, 0x94, 0x97, 0x64, 0x7c, 0x1d,
	0xae, 0x16, 0x07, 0xd1, 0xc5, 0x5a, 0x17, 0x9d, 0xa8, 0x5b, 0xcd, 0x26, 0x31, 0x75, 0x52, 0xfb,
	0xc2, 0xef, 0xff, 0xf4, 0x51, 0x02, 0x4b, 0x99, 0x42, 0xf0, 0x5c, 0x7c, 0x0b, 0x5d, 0xc5, 0xdf,
	0x41, 0x30, 0xca, 0xf7, 0xdb, 0xdb, 0x3c, 0x09, 0xe2, 0xfd, 0xb6, 0xb2, 0x2a, 0xcc, 0x74, 0x11,
	0xef, 0x6d, 0x86, 0xa0, 0x5e, 0xe7, 0x50, 0x9f, 0x86, 0x85, 0x30, 0xe1, 0xc9, 0x30, 0x7e, 0x86,
	0x60, 0x6c, 0x95, 0x78, 0x7e, 0xa2, 0xce, 0xc6, 0x82, 0x5c, 0x2b, 0x09, 0xf3, 0xc7, 0x9e, 0x97,
	0xa5, 0xff, 0x6d, 0x2b, 0x6f, 0x0b, 0x0b, 0xab, 0xc4, 0x13, 0x35, 0x1f, 0x02, 0xa9, 0x05, 0x71,
	0x3d, 0xe3, 0x8a, 0xbc, 0xe4, 0xd6, 0x27, 0x29, 0xf2, 0x25, 0x9c, 0x09, 0xdd, 0xbb, 0xd6, 0x2f,
	0x40, 0x72, 0x79, 0x69, 0x19, 0xcf, 0xc0, 0x54, 0xe0, 0xad, 0x68, 0x5a, 0x9e, 0x78, 0x60, 0xb5,
	0x4c, 0x6e, 0xc1, 0x24, 0xc6, 0x21, 0x0b, 0x0a, 0xef, 0x1a, 0xb5, 0xff, 0xc3, 0xbf, 0x44, 0x30,
	0xaa, 0x12, 0xbe, 0xe7, 0x49, 0xfc, 0xfc, 0x10, 0xb5, 0x95, 0x03, 0x61, 0xa6, 0xa3, 0x42, 0xd4,
	0xcc, 0x90, 0xa3, 0xaf, 0x71, 0x47, 0x5f, 0x06, 0x29, 0x08, 0xcc, 0x21, 0x83, 0xfc, 0xfc, 0x58,
	0x56, 0xcc, 0xc8, 0x03, 0xac, 0xa0, 0xc1, 0xf8, 0x1c, 0xc1, 0xe8, 0xae, 0xe9, 0x1b, 0x72, 0x6c,
	0x2c, 0xe2, 0x4c, 0xf9, 0x19, 0x6a, 0x2b, 0xdf, 0x40, 0xc2, 0xbc, 0x4a, 0x9a, 0xd6, 0x21, 0x89,
	0x89, 0xc4, 0xfa, 0x1c, 0xb5, 0x68, 0x19, 0x4f, 0xc1, 0xb9, 0xb0, 0x45, 0x54, 0xe6, 0x91, 0x26,
	0xac, 0xbf, 0x4c, 0xe9, 0xff, 0x8e, 0x9f, 0x87, 0x9b, 0x21, 0xe9, 0x96, 0x69, 0x1a, 0x66, 0xfd,
	0xba, 0xd8, 0x6c, 0xb9, 0x9e, 0xb8, 0x4f, 0x44, 0xd7, 0xb3, 0x6c, 0x9b, 0xd4, 0xc4, 0x7d, 0x72,
	0x60, 0x39, 0x84, 0x6b, 0xd7, 0x1a, 0x3c, 0x8c, 0x57, 0x07, 0x38, 0x40, 0xfe, 0x7e, 0x0a, 0x66,
	0x03, 0x1a, 0x7b, 0xf9, 0xe5, 0xf7, 0x81, 0xcf, 0x11, 0x0c, 0x57, 0x3d, 0xcd, 0xf1, 0xf0, 0x85,
	0xe3, 0x3f, 0x68, 0x1c, 0xeb, 0x9d, 0xaf, 0x21, 0x61, 0x8e, 0x69, 0x89, 0x73, 0xce, 0x65, 0x1e,
	0xee, 0xf9, 0x10, 0x18, 0x9a, 0xba, 0x4e, 0x30, 0xce, 0x4b, 0xdc, 0x85, 0xcf, 0xc2, 0x33, 0x41,
	0x2e, 0xad, 0xe1, 0x10, 0xad, 0x76, 0xd4, 0x71, 0x86, 0x68, 0x39, 0x5c, 0xd0, 0x30, 0xeb, 0x8f,
	0x95, 0x19, 0xe7, 0x07, 0x66, 0x46, 0x52, 0x6f, 0xd6, 0xf0, 0x17, 0x13, 0x30, 0x54, 0xf5, 0x2c,
	0xfb, 0xc4, 0xc6, 0xff, 0x02, 0xb5, 0x95, 0x6f, 0x23, 0x61, 0x96, 0x2a, 0x89, 0xb3, 0xfd, 0x19,
	0x6e, 0xbb, 0x08, 0x17, 0x42, 0xb6, 0xdf, 0x6b, 0x79, 0x35, 0xeb, 0x81, 0x19, 0x30, 0xff, 0xdf,
	0xb8, 0xf9, 0x4b, 0x90, 0x1f, 0x64, 0x3e, 0x15, 0x10, 0x99, 0x04, 0x75, 0xc0, 0xbd, 0x16, 0x1b,
	0xbc, 0xec, 0xc5, 0x69, 0xbd, 0xf0, 0x41, 0x02, 0x46, 0x54, 0xe2, 0x9e, 0x2a, 0x0b, 0x3e, 0x43,
	0x6d, 0xe5, 0x13, 0x24, 0x5c, 0xf0, 0xf5, 0xc4, 0xf9, 0xe2, 0x0a, 0xf7, 0xc5, 0x45, 0x98, 0x0f,
	0x17, 0x49, 0x34, 0x13, 0x96, 0xb9, 0x2b, 0x6e, 0xc0, 0xb5, 0x81, 0x99, 0xc0, 0xf9, 0x49, 0x8d,
	0xba, 0xc2, 0x5f, 0x9c, 0x3e, 0x1b, 0xe4, 0xf7, 0x87, 0x61, 0x72, 0xaf, 0xb2, 0xd2, 0x3f, 0x2c,
	0x8f, 0x20, 0xc5, 0x5f, 0xe2, 0xfe, 0x4f, 0x13, 0xb1, 0x1e, 0x29, 0xb5, 0x95, 0xe7, 0x84, 0xf1,
	0xde, 0xa0, 0xa9, 0xac, 0xac, 0x5f, 0xe2, 0xd6, 0x0b, 0x90, 0xdb, 0xab, 0xac, 0xc4, 0x8f, 0x14,
	0x90, 0x86, 0x0b, 0x87, 0xe6, 0x01, 0x1b, 0x25, 0xef, 0x87, 0x46, 0xc9, 0xb9, 0xbe, 0xed, 0x1f,
	0x3d, 0x42, 0x6e, 0xb7, 0x95, 0x6b, 0xc2, 0x6c, 0x64, 0x84, 0xec, 0x55, 0x56, 0x7a, 0xa3, 0x63,
	0x9c, 0x8f, 0x8e, 0x61, 0xf6, 0xcd, 0x89, 0x21, 0x18, 0xc7, 0xc0, 0x10, 0xf0, 0x51, 0xf0, 0xcd,
	0xe0, 0x28, 0x78, 0x02, 0x0f, 0x90, 0xb6, 0xb2, 0x29, 0x4c, 0xf4, 0x26, 0x00, 0xf3, 0xc1, 0x02,
	0xf7, 0xc1, 0x1c, 0x08, 0xd4, 0x07, 0x31, 0x0d, 0x7f, 0x9a, 0x07, 0xf2, 0x0c, 0x64, 0x28, 0x53,
	0x38, 0x80, 0x67, 0xe4, 0x00, 0x36, 0xea, 0xa2, 0xdf, 0x04, 0x1b, 0xfc, 0x40, 0x0f, 0xc5, 0x01,
	0xfc, 0x10, 0xb5, 0x95, 0x77, 0x85, 0xa9, 0xfe, 0xbe, 0x4e, 0x81, 0x4e, 0xf2, 0x14, 0xcc, 0x40,
	0x9a, 0x03, 0xe5, 0x7d, 0x3c, 0x06, 0x19, 0x4d, 0x58, 0xda, 0xbf, 0x6f, 0xc0, 0x35, 0xc6, 0xfd,
	0x04, 0x7d, 0x7b, 0xfc, 0x6a, 0xc0, 0x1e, 0xf9, 0x7b, 0xc3, 0x70, 0x6e, 0xaf, 0xb2, 0xd2, 0xd7,
	0xa7, 0x7f, 0x77, 0xea, 0x3e, 0x4d, 0x8d, 0x3d, 0x14, 0x26, 0xfb, 0xda, 0x34, 0xb5, 0x75, 0x8e,
	0x07, 0x65, 0x8a, 0xed, 0xdd, 0xd7, 0x96, 0x17, 0xb9, 0x27, 0x2e, 0xc1, 0x45, 0x4a, 0x3d, 0xae,
	0x1d, 0x1f, 0x17, 0xb7, 0xb3, 0xa1, 0xb8, 0xb1, 0xc6, 0xf3, 0x07, 0x74, 0xca, 0xf6, 0xfb, 0x75,
	0xd4, 0x56, 0xde, 0x13, 0xce, 0x45, 0xbb, 0x2f, 0x35, 0xe9, 0x22, 0x37, 0x29, 0x07, 0xd3, 0xcc,
	0xa4, 0xfe, 0x6e, 0x5b, 0xe0, 0x56, 0x2d, 0xc2, 0x95, 0xa0, 0x55, 0xc7, 0x74, 0xd9, 0x27, 0x34,
	0xee, 0x8f, 0xe8, 0xf4, 0x5d, 0xf5, 0x63, 0xd4, 0x56, 0xfe, 0x5f, 0x98, 0x1e, 0xd0, 0x54, 0xa9,
	0x89, 0x17, 0xb8, 0x89, 0x33, 0x30, 0xc5, 0x33, 0x34, 0x1a, 0xb7, 0xeb, 0xdc, 0x42, 0x7a, 0x98,
	0x0d, 0xc6, 0x2d, 0xa6, 0x79, 0x3e, 0x99, 0x79, 0xf2, 0xaf, 0x86, 0x21, 0xdb, 0xbd, 0xb4, 0x74,
	0xb2, 0xf4, 0x07, 0x08, 0x52, 0xbb, 0x76, 0x4d, 0xf3, 0x08, 0x7e, 0xc4, 0xb5, 0x38, 0xd6, 0xe4,
	0xfb, 0xb4, 0x69, 0x5c, 0xe2, 0x4a, 0xe8, 0xa1, 0xb1, 0x7b, 0xdf, 0xa6, 0x97, 0x8b, 0x03, 0xa3,
	0xde, 0x72, 0xf8, 0x24, 0xe9, 0x25, 0xe5, 0xda, 0x60, 0x0e, 0xb1, 0xc5, 0x74, 0x70, 0x03, 0xa6,
	0xe4, 0x6c, 0xa1, 0x77, 0x73, 0xef, 0xb6, 0x8e, 0x1f, 0x23, 0x80, 0x3b, 0xad, 0xc6, 0x7d, 0x1f,
	0xf3, 0xc5, 0xe3, 0x31, 0xbb, 0xb1, 0xa0, 0x4d, 0x7a, 0x0d, 0x5a, 0xf4, 0x41, 0x37, 0x5b, 0x0d,
	0xcf, 0xb0, 0x1b, 0x24, 0x0e, 0xba, 0xbb, 0xfe, 0x2c, 0xc7, 0x2e, 0x81, 0x18, 0x83, 0xdd, 0x0d,
	0x81, 0xcf, 0xca, 0xe9, 0x00, 0x78, 0x8a, 0xfb, 0x53, 0x04, 0xa9, 0x55, 0xe2, 0x29, 0x8d, 0x06,
	0x8e, 0x81, 0x24, 0x3c, 0xca, 0x16, 0xe9, 0xbf, 0xdb, 0xca, 0xba, 0xf0, 0xb4, 0x4a, 0x3c, 0xc7,
	0x20, 0xb4, 0xfb, 0x35, 0x1a, 0xf1, 0x80, 0x2f, 0xf1, 0x09, 0x21, 0x40, 0x2e, 0x0e, 0x30, 0x03,
	0x9a, 0xc1, 0x41, 0xa0, 0xf8, 0xbb, 0x08, 0x92, 0xab, 0xc4, 0x8b, 0xde, 0x1e, 0x02, 0x57, 0x5d,
	0xe1, 0x11, 0x59, 0xc2, 0x6f, 0x6b, 0x0b, 0x3d, 0x90, 0xf1, 0xf9, 0x20, 0x72, 0x88, 0xe7, 0x61,
	0x26, 0x06, 0x22, 0xbf, 0xad, 0xe1, 0xbe, 0x3c, 0x90, 0x1f, 0x8e, 0x40, 0x9a, 0x5e, 0xa3, 0x3b,
	0x49, 0xfc, 0x11, 0x82, 0x54, 0xd1, 0x21, 0x34, 0x21, 0xe2, 0x3f, 0xa0, 0xc4, 0xa6, 0xc2, 0x5e,
	0x5b, 0xb9, 0x23, 0xcc, 0x72, 0x79, 0x51, 0x13, 0xdf, 0xb1, 0xcc, 0x28, 0xd2, 0x05, 0x8e, 0x74,
	0x0e, 0x84, 0xb7, 0xfa, 0x88, 0xa2, 0xce, 0x04, 0x79, 0xdc, 0xd3, 0x52, 0xaa, 0xc0, 0x3e, 0xe7,
	0xd0, 0x90, 0x7f, 0xdc, 0x2b, 0xad, 0x13, 0xa0, 0x7a, 0x9b, 0xa1, 0xea, 0x54, 0x55, 0x2c, 0xaa,
	0xe5, 0x18, 0x54, 0xd1, 0x6c, 0x64, 0xa8, 0xba, 0x55, 0xf4, 0x51, 0xb8, 0x8a, 0x84, 0x58, 0x78,
	0xf1, 0x05, 0xf4, 0x5f, 0x6d, 0xe5, 0x15, 0x61, 0x21, 0x5a, 0x40, 0xfd, 0x30, 0x5d, 0xda, 0xa6,
	0x64, 0xde, 0xa6, 0x98, 0xc6, 0x10, 0xb4, 0xb4, 0x1c, 0x70, 0xd8, 0x57, 0x1f, 0x5d, 0x23, 0xc7,
	0x20, 0xa5, 0x88, 0x6e, 0x0b, 0x62, 0xa8, 0x3c, 0x06, 0xc1, 0x99, 0xe3, 0xc1, 0x9c, 0x82, 0x73,
	0xfd, 0x6e, 0xe3, 0x45, 0x31, 0x8a, 0x7d, 0x50, 0xf8, 0xcb, 0x7e, 0x3d, 0x4c, 0x86, 0xb7, 0xe5,
	0x9f, 0x70, 0x84, 0xf8, 0xa8, 0x4a, 0x6a, 0x5b, 0x79, 0x99, 0x5e, 0x3f, 0x3b, 0x58, 0x06, 0xc5,
	0x6f, 0x96, 0x03, 0x99, 0x04, 0xdc, 0x0f, 0xa4, 0x5b, 0x9c, 0xbd, 0xb8, 0xe1, 0x0f, 0x11, 0x3d,
	0xd4, 0x36, 0x88, 0x47, 0x62, 0xf0, 0xc4, 0x85, 0xea, 0x0d, 0x96, 0x4a, 0x5c, 0xf4, 0x04, 0xa9,
	0x54, 0x63, 0x82, 0x3c, 0x5e, 0x99, 0xab, 0x41, 0x48, 0xf2, 0xcf, 0x11, 0xe4, 0x02, 0x07, 0x77,
	0xfe, 0x1f, 0x5f, 0xa7, 0x2a, 0x3f, 0x45, 0x90, 0xac, 0x12, 0x0f, 0x0f, 0xfe, 0x33, 0x8b, 0xf3,
	0xc6, 0x62, 0xae, 0xd3, 0x36, 0x72, 0x99, 0x17, 0x65, 0xa1, 0xd5, 0x9d, 0x2d, 0xc1, 0x0f, 0x3c,
	0x36, 0xd3, 0x90, 0xe7, 0xe7, 0x86, 0x65, 0x7a, 0x6e, 0x50, 0xfa, 0xa8, 0xa2, 0x4b, 0xbc, 0x63,
	0x3f, 0x36, 0xc8, 0x3f, 0x45, 0x30, 0xdd, 0xed, 0x3f, 0x61, 0x03, 0xbe, 0x75, 0x1a, 0x03, 0xb4,
	0xb6, 0x52, 0x14, 0xa4, 0x3e, 0x03, 0x7a, 0xcd, 0xb0, 0x03, 0x7f, 0x9e, 0xc3, 0x9f, 0x86, 0xc9,
	0xb5, 0x08, 0xad, 0x0b, 0x7e, 0xf0, 0x2c, 0x94, 0x7f, 0x38, 0x04, 0x50, 0xaa, 0x54, 0x3b, 0x70,
	0xdf, 0x83, 0xa1, 0x2a, 0xf1, 0x94, 0x28, 0xdc, 0xd0, 0x57, 0xd0, 0x58, 0xb8, 0x77, 0xda, 0xca,
	0x4d, 0x61, 0xba, 0xca, 0xee, 0x1c, 0xa5, 0x4a, 0x55, 0x54, 0x44, 0x87, 0xc9, 0x50, 0x0c, 0xeb,
	0xe7, 0x39, 0x44, 0x0c, 0xd9, 0x28, 0x89, 0xc1, 0x4b, 0xc9, 0xa8, 0x40, 0xeb, 0xf7, 0x03, 0x04,
	0x23, 0x3c, 0xcb, 0x4e, 0x08, 0xa2, 0xdc, 0x56, 0x5e, 0x10, 0xce, 0x77, 0x13, 0xf5, 0xa4, 0x38,
	0x1e, 0x22, 0xc8, 0x54, 0x89, 0x17, 0xf8, 0x5e, 0xdc, 0x8f, 0xa6, 0x47, 0x8c, 0x45, 0x73, 0x9b,
	0x5e, 0x07, 0x31, 0x75, 0x09, 0xdd, 0xed, 0xa0, 0x2b, 0xc0, 0x0b, 0x77, 0x99, 0x16, 0x6e, 0x98,
	0xd0, 0x07, 0xe4, 0x43, 0x04, 0x59, 0x6e, 0xcd, 0x69, 0xb1, 0xac, 0xb6, 0x95, 0x17, 0x85, 0x29,
	0xdf, 0x33, 0x11, 0x38, 0xbd, 0xfc, 0x8f, 0xc0, 0x09, 0x16, 0xae, 0x0f, 0xe9, 0xce, 0x5f, 0x50,
	0x5b, 0xf9, 0x35, 0xc2, 0x9f, 0x20, 0xc8, 0x94, 0x37, 0x94, 0xde, 0x69, 0x46, 0x7a, 0x05, 0xa0,
	0xda, 0xa4, 0xa7, 0xd1, 0x72, 0xad, 0x4e, 0xf0, 0x8c, 0x6e, 0xd5, 0x48, 0xde, 0xa5, 0x2f, 0x6e,
	0x90, 0x5a, 0x9d, 0xe4, 0x75, 0xab, 0x59, 0x20, 0x0d, 0x4d, 0x98, 0x76, 0x5b, 0xb6, 0x6d, 0x39,
	0xde, 0xed, 0x30, 0xed, 0xea, 0x1a, 0x60, 0xc5, 0xd6, 0xf4, 0x7b, 0x44, 0x94, 0xf3, 0x4b, 0xe2,
	0x86, 0xa1, 0x13, 0xd3, 0x25, 0xf8, 0xe6, 0x3d, 0xcf, 0xb3, 0xdd, 0x5b, 0x85, 0x42, 0xdd, 0xf0,
	0xee, 0xb5, 0xf6, 0x99, 0x16, 0x26, 0x48, 0xe5, 0x9a, 0x44, 0x2f, 0xec, 0x37, 0xac, 0xfd, 0x42,
	0x53, 0x73, 0x3d, 0xe2, 0x14, 0x36, 0xd6, 0x8a, 0xe5, 0x4a, 0xb5, 0x2c, 0x27, 0x9f, 0xcb, 0x2f,
	0x5d, 0x45, 0x09, 0x39, 0x1b, 0xa8, 0xd7, 0xc2, 0xff, 0xb8, 0x96, 0x79, 0xab, 0xef, 0xcd, 0x5b,
	0x42, 0x0c, 0xce, 0x82, 0xbd, 0xbf, 0x9f, 0x62, 0x3e, 0xbc, 0xf9, 0xcf, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xc5, 0x5e, 0x35, 0x93, 0xac, 0x24, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ApplicationDeploymentServiceClient is the client API for ApplicationDeploymentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ApplicationDeploymentServiceClient interface {
	DeployContainer(ctx context.Context, in *Application, opts ...grpc.CallOption) (*empty.Empty, error)
	DeployVM(ctx context.Context, in *Application, opts ...grpc.CallOption) (*empty.Empty, error)
	GetStatus(ctx context.Context, in *ApplicationID, opts ...grpc.CallOption) (*LifecycleStatus, error)
	Redeploy(ctx context.Context, in *Application, opts ...grpc.CallOption) (*empty.Empty, error)
	Undeploy(ctx context.Context, in *ApplicationID, opts ...grpc.CallOption) (*empty.Empty, error)
}

type applicationDeploymentServiceClient struct {
	cc *grpc.ClientConn
}

func NewApplicationDeploymentServiceClient(cc *grpc.ClientConn) ApplicationDeploymentServiceClient {
	return &applicationDeploymentServiceClient{cc}
}

func (c *applicationDeploymentServiceClient) DeployContainer(ctx context.Context, in *Application, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationDeploymentService/DeployContainer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationDeploymentServiceClient) DeployVM(ctx context.Context, in *Application, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationDeploymentService/DeployVM", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationDeploymentServiceClient) GetStatus(ctx context.Context, in *ApplicationID, opts ...grpc.CallOption) (*LifecycleStatus, error) {
	out := new(LifecycleStatus)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationDeploymentService/GetStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationDeploymentServiceClient) Redeploy(ctx context.Context, in *Application, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationDeploymentService/Redeploy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationDeploymentServiceClient) Undeploy(ctx context.Context, in *ApplicationID, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationDeploymentService/Undeploy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApplicationDeploymentServiceServer is the server API for ApplicationDeploymentService service.
type ApplicationDeploymentServiceServer interface {
	DeployContainer(context.Context, *Application) (*empty.Empty, error)
	DeployVM(context.Context, *Application) (*empty.Empty, error)
	GetStatus(context.Context, *ApplicationID) (*LifecycleStatus, error)
	Redeploy(context.Context, *Application) (*empty.Empty, error)
	Undeploy(context.Context, *ApplicationID) (*empty.Empty, error)
}

// UnimplementedApplicationDeploymentServiceServer can be embedded to have forward compatible implementations.
type UnimplementedApplicationDeploymentServiceServer struct {
}

func (*UnimplementedApplicationDeploymentServiceServer) DeployContainer(ctx context.Context, req *Application) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeployContainer not implemented")
}
func (*UnimplementedApplicationDeploymentServiceServer) DeployVM(ctx context.Context, req *Application) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeployVM not implemented")
}
func (*UnimplementedApplicationDeploymentServiceServer) GetStatus(ctx context.Context, req *ApplicationID) (*LifecycleStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatus not implemented")
}
func (*UnimplementedApplicationDeploymentServiceServer) Redeploy(ctx context.Context, req *Application) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Redeploy not implemented")
}
func (*UnimplementedApplicationDeploymentServiceServer) Undeploy(ctx context.Context, req *ApplicationID) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Undeploy not implemented")
}

func RegisterApplicationDeploymentServiceServer(s *grpc.Server, srv ApplicationDeploymentServiceServer) {
	s.RegisterService(&_ApplicationDeploymentService_serviceDesc, srv)
}

func _ApplicationDeploymentService_DeployContainer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Application)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationDeploymentServiceServer).DeployContainer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationDeploymentService/DeployContainer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationDeploymentServiceServer).DeployContainer(ctx, req.(*Application))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationDeploymentService_DeployVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Application)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationDeploymentServiceServer).DeployVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationDeploymentService/DeployVM",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationDeploymentServiceServer).DeployVM(ctx, req.(*Application))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationDeploymentService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplicationID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationDeploymentServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationDeploymentService/GetStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationDeploymentServiceServer).GetStatus(ctx, req.(*ApplicationID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationDeploymentService_Redeploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Application)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationDeploymentServiceServer).Redeploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationDeploymentService/Redeploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationDeploymentServiceServer).Redeploy(ctx, req.(*Application))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationDeploymentService_Undeploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplicationID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationDeploymentServiceServer).Undeploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationDeploymentService/Undeploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationDeploymentServiceServer).Undeploy(ctx, req.(*ApplicationID))
	}
	return interceptor(ctx, in, info, handler)
}

var _ApplicationDeploymentService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.ela.ApplicationDeploymentService",
	HandlerType: (*ApplicationDeploymentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeployContainer",
			Handler:    _ApplicationDeploymentService_DeployContainer_Handler,
		},
		{
			MethodName: "DeployVM",
			Handler:    _ApplicationDeploymentService_DeployVM_Handler,
		},
		{
			MethodName: "GetStatus",
			Handler:    _ApplicationDeploymentService_GetStatus_Handler,
		},
		{
			MethodName: "Redeploy",
			Handler:    _ApplicationDeploymentService_Redeploy_Handler,
		},
		{
			MethodName: "Undeploy",
			Handler:    _ApplicationDeploymentService_Undeploy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ela.proto",
}

// ApplicationLifecycleServiceClient is the client API for ApplicationLifecycleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ApplicationLifecycleServiceClient interface {
	Start(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error)
	Stop(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error)
	Restart(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error)
}

type applicationLifecycleServiceClient struct {
	cc *grpc.ClientConn
}

func NewApplicationLifecycleServiceClient(cc *grpc.ClientConn) ApplicationLifecycleServiceClient {
	return &applicationLifecycleServiceClient{cc}
}

func (c *applicationLifecycleServiceClient) Start(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationLifecycleService/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationLifecycleServiceClient) Stop(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationLifecycleService/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *applicationLifecycleServiceClient) Restart(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationLifecycleService/Restart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApplicationLifecycleServiceServer is the server API for ApplicationLifecycleService service.
type ApplicationLifecycleServiceServer interface {
	Start(context.Context, *LifecycleCommand) (*empty.Empty, error)
	Stop(context.Context, *LifecycleCommand) (*empty.Empty, error)
	Restart(context.Context, *LifecycleCommand) (*empty.Empty, error)
}

// UnimplementedApplicationLifecycleServiceServer can be embedded to have forward compatible implementations.
type UnimplementedApplicationLifecycleServiceServer struct {
}

func (*UnimplementedApplicationLifecycleServiceServer) Start(ctx context.Context, req *LifecycleCommand) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
}
func (*UnimplementedApplicationLifecycleServiceServer) Stop(ctx context.Context, req *LifecycleCommand) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (*UnimplementedApplicationLifecycleServiceServer) Restart(ctx context.Context, req *LifecycleCommand) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Restart not implemented")
}

func RegisterApplicationLifecycleServiceServer(s *grpc.Server, srv ApplicationLifecycleServiceServer) {
	s.RegisterService(&_ApplicationLifecycleService_serviceDesc, srv)
}

func _ApplicationLifecycleService_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationLifecycleServiceServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationLifecycleService/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationLifecycleServiceServer).Start(ctx, req.(*LifecycleCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationLifecycleService_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationLifecycleServiceServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationLifecycleService/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationLifecycleServiceServer).Stop(ctx, req.(*LifecycleCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApplicationLifecycleService_Restart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationLifecycleServiceServer).Restart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationLifecycleService/Restart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationLifecycleServiceServer).Restart(ctx, req.(*LifecycleCommand))
	}
	return interceptor(ctx, in, info, handler)
}

var _ApplicationLifecycleService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.ela.ApplicationLifecycleService",
	HandlerType: (*ApplicationLifecycleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Start",
			Handler:    _ApplicationLifecycleService_Start_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _ApplicationLifecycleService_Stop_Handler,
		},
		{
			MethodName: "Restart",
			Handler:    _ApplicationLifecycleService_Restart_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ela.proto",
}

// VNFDeploymentServiceClient is the client API for VNFDeploymentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VNFDeploymentServiceClient interface {
	Deploy(ctx context.Context, in *VNF, opts ...grpc.CallOption) (*empty.Empty, error)
	GetStatus(ctx context.Context, in *VNFID, opts ...grpc.CallOption) (*LifecycleStatus, error)
	Redeploy(ctx context.Context, in *VNF, opts ...grpc.CallOption) (*empty.Empty, error)
	Undeploy(ctx context.Context, in *VNFID, opts ...grpc.CallOption) (*empty.Empty, error)
}

type vNFDeploymentServiceClient struct {
	cc *grpc.ClientConn
}

func NewVNFDeploymentServiceClient(cc *grpc.ClientConn) VNFDeploymentServiceClient {
	return &vNFDeploymentServiceClient{cc}
}

func (c *vNFDeploymentServiceClient) Deploy(ctx context.Context, in *VNF, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.VNFDeploymentService/Deploy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNFDeploymentServiceClient) GetStatus(ctx context.Context, in *VNFID, opts ...grpc.CallOption) (*LifecycleStatus, error) {
	out := new(LifecycleStatus)
	err := c.cc.Invoke(ctx, "/openness.ela.VNFDeploymentService/GetStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNFDeploymentServiceClient) Redeploy(ctx context.Context, in *VNF, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.VNFDeploymentService/Redeploy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNFDeploymentServiceClient) Undeploy(ctx context.Context, in *VNFID, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.VNFDeploymentService/Undeploy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VNFDeploymentServiceServer is the server API for VNFDeploymentService service.
type VNFDeploymentServiceServer interface {
	Deploy(context.Context, *VNF) (*empty.Empty, error)
	GetStatus(context.Context, *VNFID) (*LifecycleStatus, error)
	Redeploy(context.Context, *VNF) (*empty.Empty, error)
	Undeploy(context.Context, *VNFID) (*empty.Empty, error)
}

// UnimplementedVNFDeploymentServiceServer can be embedded to have forward compatible implementations.
type UnimplementedVNFDeploymentServiceServer struct {
}

func (*UnimplementedVNFDeploymentServiceServer) Deploy(ctx context.Context, req *VNF) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deploy not implemented")
}
func (*UnimplementedVNFDeploymentServiceServer) GetStatus(ctx context.Context, req *VNFID) (*LifecycleStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatus not implemented")
}
func (*UnimplementedVNFDeploymentServiceServer) Redeploy(ctx context.Context, req *VNF) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Redeploy not implemented")
}
func (*UnimplementedVNFDeploymentServiceServer) Undeploy(ctx context.Context, req *VNFID) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Undeploy not implemented")
}

func RegisterVNFDeploymentServiceServer(s *grpc.Server, srv VNFDeploymentServiceServer) {
	s.RegisterService(&_VNFDeploymentService_serviceDesc, srv)
}

func _VNFDeploymentService_Deploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNF)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFDeploymentServiceServer).Deploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.VNFDeploymentService/Deploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFDeploymentServiceServer).Deploy(ctx, req.(*VNF))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNFDeploymentService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNFID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFDeploymentServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.VNFDeploymentService/GetStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFDeploymentServiceServer).GetStatus(ctx, req.(*VNFID))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNFDeploymentService_Redeploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNF)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFDeploymentServiceServer).Redeploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.VNFDeploymentService/Redeploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFDeploymentServiceServer).Redeploy(ctx, req.(*VNF))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNFDeploymentService_Undeploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNFID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFDeploymentServiceServer).Undeploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.VNFDeploymentService/Undeploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFDeploymentServiceServer).Undeploy(ctx, req.(*VNFID))
	}
	return interceptor(ctx, in, info, handler)
}

var _VNFDeploymentService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.ela.VNFDeploymentService",
	HandlerType: (*VNFDeploymentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Deploy",
			Handler:    _VNFDeploymentService_Deploy_Handler,
		},
		{
			MethodName: "GetStatus",
			Handler:    _VNFDeploymentService_GetStatus_Handler,
		},
		{
			MethodName: "Redeploy",
			Handler:    _VNFDeploymentService_Redeploy_Handler,
		},
		{
			MethodName: "Undeploy",
			Handler:    _VNFDeploymentService_Undeploy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ela.proto",
}

// VNFLifecycleServiceClient is the client API for VNFLifecycleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VNFLifecycleServiceClient interface {
	Start(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error)
	Stop(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error)
	Restart(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error)
}

type vNFLifecycleServiceClient struct {
	cc *grpc.ClientConn
}

func NewVNFLifecycleServiceClient(cc *grpc.ClientConn) VNFLifecycleServiceClient {
	return &vNFLifecycleServiceClient{cc}
}

func (c *vNFLifecycleServiceClient) Start(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.VNFLifecycleService/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNFLifecycleServiceClient) Stop(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.VNFLifecycleService/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vNFLifecycleServiceClient) Restart(ctx context.Context, in *LifecycleCommand, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.VNFLifecycleService/Restart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VNFLifecycleServiceServer is the server API for VNFLifecycleService service.
type VNFLifecycleServiceServer interface {
	Start(context.Context, *LifecycleCommand) (*empty.Empty, error)
	Stop(context.Context, *LifecycleCommand) (*empty.Empty, error)
	Restart(context.Context, *LifecycleCommand) (*empty.Empty, error)
}

// UnimplementedVNFLifecycleServiceServer can be embedded to have forward compatible implementations.
type UnimplementedVNFLifecycleServiceServer struct {
}

func (*UnimplementedVNFLifecycleServiceServer) Start(ctx context.Context, req *LifecycleCommand) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
}
func (*UnimplementedVNFLifecycleServiceServer) Stop(ctx context.Context, req *LifecycleCommand) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (*UnimplementedVNFLifecycleServiceServer) Restart(ctx context.Context, req *LifecycleCommand) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Restart not implemented")
}

func RegisterVNFLifecycleServiceServer(s *grpc.Server, srv VNFLifecycleServiceServer) {
	s.RegisterService(&_VNFLifecycleService_serviceDesc, srv)
}

func _VNFLifecycleService_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFLifecycleServiceServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.VNFLifecycleService/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFLifecycleServiceServer).Start(ctx, req.(*LifecycleCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNFLifecycleService_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFLifecycleServiceServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.VNFLifecycleService/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFLifecycleServiceServer).Stop(ctx, req.(*LifecycleCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _VNFLifecycleService_Restart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LifecycleCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VNFLifecycleServiceServer).Restart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.VNFLifecycleService/Restart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VNFLifecycleServiceServer).Restart(ctx, req.(*LifecycleCommand))
	}
	return interceptor(ctx, in, info, handler)
}

var _VNFLifecycleService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.ela.VNFLifecycleService",
	HandlerType: (*VNFLifecycleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Start",
			Handler:    _VNFLifecycleService_Start_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _VNFLifecycleService_Stop_Handler,
		},
		{
			MethodName: "Restart",
			Handler:    _VNFLifecycleService_Restart_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ela.proto",
}

// InterfaceServiceClient is the client API for InterfaceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InterfaceServiceClient interface {
	Update(ctx context.Context, in *NetworkInterface, opts ...grpc.CallOption) (*empty.Empty, error)
	BulkUpdate(ctx context.Context, in *NetworkInterfaces, opts ...grpc.CallOption) (*empty.Empty, error)
	GetAll(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*NetworkInterfaces, error)
	Get(ctx context.Context, in *InterfaceID, opts ...grpc.CallOption) (*NetworkInterface, error)
}

type interfaceServiceClient struct {
	cc *grpc.ClientConn
}

func NewInterfaceServiceClient(cc *grpc.ClientConn) InterfaceServiceClient {
	return &interfaceServiceClient{cc}
}

func (c *interfaceServiceClient) Update(ctx context.Context, in *NetworkInterface, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.InterfaceService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfaceServiceClient) BulkUpdate(ctx context.Context, in *NetworkInterfaces, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.InterfaceService/BulkUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfaceServiceClient) GetAll(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*NetworkInterfaces, error) {
	out := new(NetworkInterfaces)
	err := c.cc.Invoke(ctx, "/openness.ela.InterfaceService/GetAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfaceServiceClient) Get(ctx context.Context, in *InterfaceID, opts ...grpc.CallOption) (*NetworkInterface, error) {
	out := new(NetworkInterface)
	err := c.cc.Invoke(ctx, "/openness.ela.InterfaceService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InterfaceServiceServer is the server API for InterfaceService service.
type InterfaceServiceServer interface {
	Update(context.Context, *NetworkInterface) (*empty.Empty, error)
	BulkUpdate(context.Context, *NetworkInterfaces) (*empty.Empty, error)
	GetAll(context.Context, *empty.Empty) (*NetworkInterfaces, error)
	Get(context.Context, *InterfaceID) (*NetworkInterface, error)
}

// UnimplementedInterfaceServiceServer can be embedded to have forward compatible implementations.
type UnimplementedInterfaceServiceServer struct {
}

func (*UnimplementedInterfaceServiceServer) Update(ctx context.Context, req *NetworkInterface) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (*UnimplementedInterfaceServiceServer) BulkUpdate(ctx context.Context, req *NetworkInterfaces) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkUpdate not implemented")
}
func (*UnimplementedInterfaceServiceServer) GetAll(ctx context.Context, req *empty.Empty) (*NetworkInterfaces, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (*UnimplementedInterfaceServiceServer) Get(ctx context.Context, req *InterfaceID) (*NetworkInterface, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}

func RegisterInterfaceServiceServer(s *grpc.Server, srv InterfaceServiceServer) {
	s.RegisterService(&_InterfaceService_serviceDesc, srv)
}

func _InterfaceService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkInterface)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.InterfaceService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceServiceServer).Update(ctx, req.(*NetworkInterface))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterfaceService_BulkUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkInterfaces)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceServiceServer).BulkUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.InterfaceService/BulkUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceServiceServer).BulkUpdate(ctx, req.(*NetworkInterfaces))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterfaceService_GetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceServiceServer).GetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.InterfaceService/GetAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceServiceServer).GetAll(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterfaceService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfaceServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.InterfaceService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfaceServiceServer).Get(ctx, req.(*InterfaceID))
	}
	return interceptor(ctx, in, info, handler)
}

var _InterfaceService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.ela.InterfaceService",
	HandlerType: (*InterfaceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Update",
			Handler:    _InterfaceService_Update_Handler,
		},
		{
			MethodName: "BulkUpdate",
			Handler:    _InterfaceService_BulkUpdate_Handler,
		},
		{
			MethodName: "GetAll",
			Handler:    _InterfaceService_GetAll_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _InterfaceService_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ela.proto",
}

// ZoneServiceClient is the client API for ZoneService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ZoneServiceClient interface {
	Create(ctx context.Context, in *NetworkZone, opts ...grpc.CallOption) (*empty.Empty, error)
	Update(ctx context.Context, in *NetworkZone, opts ...grpc.CallOption) (*empty.Empty, error)
	BulkUpdate(ctx context.Context, in *NetworkZones, opts ...grpc.CallOption) (*empty.Empty, error)
	GetAll(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*NetworkZones, error)
	Get(ctx context.Context, in *ZoneID, opts ...grpc.CallOption) (*NetworkZone, error)
	Delete(ctx context.Context, in *ZoneID, opts ...grpc.CallOption) (*empty.Empty, error)
}

type zoneServiceClient struct {
	cc *grpc.ClientConn
}

func NewZoneServiceClient(cc *grpc.ClientConn) ZoneServiceClient {
	return &zoneServiceClient{cc}
}

func (c *zoneServiceClient) Create(ctx context.Context, in *NetworkZone, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ZoneService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneServiceClient) Update(ctx context.Context, in *NetworkZone, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ZoneService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneServiceClient) BulkUpdate(ctx context.Context, in *NetworkZones, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ZoneService/BulkUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneServiceClient) GetAll(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*NetworkZones, error) {
	out := new(NetworkZones)
	err := c.cc.Invoke(ctx, "/openness.ela.ZoneService/GetAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneServiceClient) Get(ctx context.Context, in *ZoneID, opts ...grpc.CallOption) (*NetworkZone, error) {
	out := new(NetworkZone)
	err := c.cc.Invoke(ctx, "/openness.ela.ZoneService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneServiceClient) Delete(ctx context.Context, in *ZoneID, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ZoneService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ZoneServiceServer is the server API for ZoneService service.
type ZoneServiceServer interface {
	Create(context.Context, *NetworkZone) (*empty.Empty, error)
	Update(context.Context, *NetworkZone) (*empty.Empty, error)
	BulkUpdate(context.Context, *NetworkZones) (*empty.Empty, error)
	GetAll(context.Context, *empty.Empty) (*NetworkZones, error)
	Get(context.Context, *ZoneID) (*NetworkZone, error)
	Delete(context.Context, *ZoneID) (*empty.Empty, error)
}

// UnimplementedZoneServiceServer can be embedded to have forward compatible implementations.
type UnimplementedZoneServiceServer struct {
}

func (*UnimplementedZoneServiceServer) Create(ctx context.Context, req *NetworkZone) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (*UnimplementedZoneServiceServer) Update(ctx context.Context, req *NetworkZone) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (*UnimplementedZoneServiceServer) BulkUpdate(ctx context.Context, req *NetworkZones) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkUpdate not implemented")
}
func (*UnimplementedZoneServiceServer) GetAll(ctx context.Context, req *empty.Empty) (*NetworkZones, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (*UnimplementedZoneServiceServer) Get(ctx context.Context, req *ZoneID) (*NetworkZone, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedZoneServiceServer) Delete(ctx context.Context, req *ZoneID) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}

func RegisterZoneServiceServer(s *grpc.Server, srv ZoneServiceServer) {
	s.RegisterService(&_ZoneService_serviceDesc, srv)
}

func _ZoneService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkZone)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ZoneService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).Create(ctx, req.(*NetworkZone))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkZone)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ZoneService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).Update(ctx, req.(*NetworkZone))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneService_BulkUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkZones)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).BulkUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ZoneService/BulkUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).BulkUpdate(ctx, req.(*NetworkZones))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneService_GetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).GetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ZoneService/GetAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).GetAll(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZoneID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ZoneService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).Get(ctx, req.(*ZoneID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZoneID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ZoneService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).Delete(ctx, req.(*ZoneID))
	}
	return interceptor(ctx, in, info, handler)
}

var _ZoneService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.ela.ZoneService",
	HandlerType: (*ZoneServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ZoneService_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ZoneService_Update_Handler,
		},
		{
			MethodName: "BulkUpdate",
			Handler:    _ZoneService_BulkUpdate_Handler,
		},
		{
			MethodName: "GetAll",
			Handler:    _ZoneService_GetAll_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ZoneService_Get_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ZoneService_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ela.proto",
}

// ApplicationPolicyServiceClient is the client API for ApplicationPolicyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ApplicationPolicyServiceClient interface {
	Set(ctx context.Context, in *TrafficPolicy, opts ...grpc.CallOption) (*empty.Empty, error)
}

type applicationPolicyServiceClient struct {
	cc *grpc.ClientConn
}

func NewApplicationPolicyServiceClient(cc *grpc.ClientConn) ApplicationPolicyServiceClient {
	return &applicationPolicyServiceClient{cc}
}

func (c *applicationPolicyServiceClient) Set(ctx context.Context, in *TrafficPolicy, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.ApplicationPolicyService/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApplicationPolicyServiceServer is the server API for ApplicationPolicyService service.
type ApplicationPolicyServiceServer interface {
	Set(context.Context, *TrafficPolicy) (*empty.Empty, error)
}

// UnimplementedApplicationPolicyServiceServer can be embedded to have forward compatible implementations.
type UnimplementedApplicationPolicyServiceServer struct {
}

func (*UnimplementedApplicationPolicyServiceServer) Set(ctx context.Context, req *TrafficPolicy) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}

func RegisterApplicationPolicyServiceServer(s *grpc.Server, srv ApplicationPolicyServiceServer) {
	s.RegisterService(&_ApplicationPolicyService_serviceDesc, srv)
}

func _ApplicationPolicyService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrafficPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApplicationPolicyServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.ApplicationPolicyService/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApplicationPolicyServiceServer).Set(ctx, req.(*TrafficPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

var _ApplicationPolicyService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.ela.ApplicationPolicyService",
	HandlerType: (*ApplicationPolicyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Set",
			Handler:    _ApplicationPolicyService_Set_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ela.proto",
}

// InterfacePolicyServiceClient is the client API for InterfacePolicyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InterfacePolicyServiceClient interface {
	Set(ctx context.Context, in *TrafficPolicy, opts ...grpc.CallOption) (*empty.Empty, error)
}

type interfacePolicyServiceClient struct {
	cc *grpc.ClientConn
}

func NewInterfacePolicyServiceClient(cc *grpc.ClientConn) InterfacePolicyServiceClient {
	return &interfacePolicyServiceClient{cc}
}

func (c *interfacePolicyServiceClient) Set(ctx context.Context, in *TrafficPolicy, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.InterfacePolicyService/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InterfacePolicyServiceServer is the server API for InterfacePolicyService service.
type InterfacePolicyServiceServer interface {
	Set(context.Context, *TrafficPolicy) (*empty.Empty, error)
}

// UnimplementedInterfacePolicyServiceServer can be embedded to have forward compatible implementations.
type UnimplementedInterfacePolicyServiceServer struct {
}

func (*UnimplementedInterfacePolicyServiceServer) Set(ctx context.Context, req *TrafficPolicy) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}

func RegisterInterfacePolicyServiceServer(s *grpc.Server, srv InterfacePolicyServiceServer) {
	s.RegisterService(&_InterfacePolicyService_serviceDesc, srv)
}

func _InterfacePolicyService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrafficPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfacePolicyServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.InterfacePolicyService/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfacePolicyServiceServer).Set(ctx, req.(*TrafficPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

var _InterfacePolicyService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.ela.InterfacePolicyService",
	HandlerType: (*InterfacePolicyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Set",
			Handler:    _InterfacePolicyService_Set_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ela.proto",
}

// DNSServiceClient is the client API for DNSService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DNSServiceClient interface {
	SetA(ctx context.Context, in *DNSARecordSet, opts ...grpc.CallOption) (*empty.Empty, error)
	DeleteA(ctx context.Context, in *DNSARecordSet, opts ...grpc.CallOption) (*empty.Empty, error)
	SetForwarders(ctx context.Context, in *DNSForwarders, opts ...grpc.CallOption) (*empty.Empty, error)
	DeleteForwarders(ctx context.Context, in *DNSForwarders, opts ...grpc.CallOption) (*empty.Empty, error)
}

type dNSServiceClient struct {
	cc *grpc.ClientConn
}

func NewDNSServiceClient(cc *grpc.ClientConn) DNSServiceClient {
	return &dNSServiceClient{cc}
}

func (c *dNSServiceClient) SetA(ctx context.Context, in *DNSARecordSet, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.DNSService/SetA", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dNSServiceClient) DeleteA(ctx context.Context, in *DNSARecordSet, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.DNSService/DeleteA", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dNSServiceClient) SetForwarders(ctx context.Context, in *DNSForwarders, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.DNSService/SetForwarders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dNSServiceClient) DeleteForwarders(ctx context.Context, in *DNSForwarders, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/openness.ela.DNSService/DeleteForwarders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DNSServiceServer is the server API for DNSService service.
type DNSServiceServer interface {
	SetA(context.Context, *DNSARecordSet) (*empty.Empty, error)
	DeleteA(context.Context, *DNSARecordSet) (*empty.Empty, error)
	SetForwarders(context.Context, *DNSForwarders) (*empty.Empty, error)
	DeleteForwarders(context.Context, *DNSForwarders) (*empty.Empty, error)
}

// UnimplementedDNSServiceServer can be embedded to have forward compatible implementations.
type UnimplementedDNSServiceServer struct {
}

func (*UnimplementedDNSServiceServer) SetA(ctx context.Context, req *DNSARecordSet) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetA not implemented")
}
func (*UnimplementedDNSServiceServer) DeleteA(ctx context.Context, req *DNSARecordSet) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteA not implemented")
}
func (*UnimplementedDNSServiceServer) SetForwarders(ctx context.Context, req *DNSForwarders) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetForwarders not implemented")
}
func (*UnimplementedDNSServiceServer) DeleteForwarders(ctx context.Context, req *DNSForwarders) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteForwarders not implemented")
}

func RegisterDNSServiceServer(s *grpc.Server, srv DNSServiceServer) {
	s.RegisterService(&_DNSService_serviceDesc, srv)
}

func _DNSService_SetA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DNSARecordSet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DNSServiceServer).SetA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.DNSService/SetA",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DNSServiceServer).SetA(ctx, req.(*DNSARecordSet))
	}
	return interceptor(ctx, in, info, handler)
}

func _DNSService_DeleteA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DNSARecordSet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DNSServiceServer).DeleteA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.DNSService/DeleteA",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DNSServiceServer).DeleteA(ctx, req.(*DNSARecordSet))
	}
	return interceptor(ctx, in, info, handler)
}

func _DNSService_SetForwarders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DNSForwarders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DNSServiceServer).SetForwarders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.DNSService/SetForwarders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DNSServiceServer).SetForwarders(ctx, req.(*DNSForwarders))
	}
	return interceptor(ctx, in, info, handler)
}

func _DNSService_DeleteForwarders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DNSForwarders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DNSServiceServer).DeleteForwarders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openness.ela.DNSService/DeleteForwarders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DNSServiceServer).DeleteForwarders(ctx, req.(*DNSForwarders))
	}
	return interceptor(ctx, in, info, handler)
}

var _DNSService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openness.ela.DNSService",
	HandlerType: (*DNSServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetA",
			Handler:    _DNSService_SetA_Handler,
		},
		{
			MethodName: "DeleteA",
			Handler:    _DNSService_DeleteA_Handler,
		},
		{
			MethodName: "SetForwarders",
			Handler:    _DNSService_SetForwarders_Handler,
		},
		{
			MethodName: "DeleteForwarders",
			Handler:    _DNSService_DeleteForwarders_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ela.proto",
}
